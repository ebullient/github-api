<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GHRepository.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GitHub API for Java</a> &gt; <a href="index.source.html" class="el_package">org.kohsuke.github</a> &gt; <span class="el_source">GHRepository.java</span></div><h1>GHRepository.java</h1><pre class="source lang-java linenums">/*
 * The MIT License
 *
 * Copyright (c) 2010, Kohsuke Kawaguchi
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package org.kohsuke.github;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.infradna.tool.bridge_method_injector.WithBridgeMethods;
import edu.umd.cs.findbugs.annotations.CheckForNull;
import edu.umd.cs.findbugs.annotations.NonNull;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import org.apache.commons.lang3.StringUtils;
import org.kohsuke.github.function.InputStreamFunction;
import org.kohsuke.github.internal.EnumUtils;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.InterruptedIOException;
import java.io.Reader;
import java.net.URL;
import java.util.AbstractSet;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.WeakHashMap;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

import static java.util.Arrays.asList;
import static java.util.Objects.requireNonNull;

// TODO: Auto-generated Javadoc
/**
 * A repository on GitHub.
 *
 * @author Kohsuke Kawaguchi
 */
@SuppressWarnings({ &quot;UnusedDeclaration&quot; })
@SuppressFBWarnings(value = { &quot;UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD&quot;, &quot;UWF_UNWRITTEN_FIELD&quot;, &quot;NP_UNWRITTEN_FIELD&quot; },
        justification = &quot;JSON API&quot;)
<span class="fc" id="L74">public class GHRepository extends GHObject {</span>

    private String nodeId, description, homepage, name, full_name;

    private String html_url; // this is the UI

    /*
     * The license information makes use of the preview API.
     *
     * See: https://developer.github.com/v3/licenses/
     */
    private GHLicense license;

    private String git_url, ssh_url, clone_url, svn_url, mirror_url;

    private GHUser owner; // not fully populated. beware.

    private boolean has_issues, has_wiki, fork, has_downloads, has_pages, archived, disabled, has_projects;

    private boolean allow_squash_merge;

    private boolean allow_merge_commit;

    private boolean allow_rebase_merge;

    private boolean allow_forking;

    private boolean delete_branch_on_merge;

    @JsonProperty(&quot;private&quot;)
    private boolean _private;

    private String visibility;

    private int forks_count, stargazers_count, watchers_count, size, open_issues_count, subscribers_count;

    private String pushed_at;

<span class="fc" id="L112">    private Map&lt;Integer, GHMilestone&gt; milestones = Collections.synchronizedMap(new WeakHashMap&lt;&gt;());</span>

    private String default_branch, language;

    private GHRepository template_repository;

<span class="fc" id="L118">    private Map&lt;String, GHCommit&gt; commits = Collections.synchronizedMap(new WeakHashMap&lt;&gt;());</span>

    @SkipFromToString
    private GHRepoPermission permissions;

    private GHRepository source, parent;

    private Boolean isTemplate;
    private boolean compareUsePaginatedCommits;

    /**
     * Read.
     *
     * @param root
     *            the root
     * @param owner
     *            the owner
     * @param name
     *            the name
     * @return the GH repository
     * @throws IOException
     *             Signals that an I/O exception has occurred.
     */
    static GHRepository read(GitHub root, String owner, String name) throws IOException {
<span class="fc" id="L142">        return root.createRequest().withUrlPath(&quot;/repos/&quot; + owner + '/' + name).fetch(GHRepository.class);</span>
    }

    /**
     * Create deployment gh deployment builder.
     *
     * @param ref
     *            the ref
     * @return the gh deployment builder
     */
    public GHDeploymentBuilder createDeployment(String ref) {
<span class="fc" id="L153">        return new GHDeploymentBuilder(this, ref);</span>
    }

    /**
     * Gets deployment statuses.
     *
     * @param id
     *            the id
     * @return the deployment statuses
     * @throws IOException
     *             the io exception
     * @deprecated Use {@code getDeployment(id).listStatuses()}
     */
    @Deprecated
    public PagedIterable&lt;GHDeploymentStatus&gt; getDeploymentStatuses(final int id) throws IOException {
<span class="nc" id="L168">        return getDeployment(id).listStatuses();</span>
    }

    /**
     * List deployments paged iterable.
     *
     * @param sha
     *            the sha
     * @param ref
     *            the ref
     * @param task
     *            the task
     * @param environment
     *            the environment
     * @return the paged iterable
     */
    public PagedIterable&lt;GHDeployment&gt; listDeployments(String sha, String ref, String task, String environment) {
<span class="fc" id="L185">        return root().createRequest()</span>
<span class="fc" id="L186">                .with(&quot;sha&quot;, sha)</span>
<span class="fc" id="L187">                .with(&quot;ref&quot;, ref)</span>
<span class="fc" id="L188">                .with(&quot;task&quot;, task)</span>
<span class="fc" id="L189">                .with(&quot;environment&quot;, environment)</span>
<span class="fc" id="L190">                .withUrlPath(getApiTailUrl(&quot;deployments&quot;))</span>
<span class="fc" id="L191">                .toIterable(GHDeployment[].class, item -&gt; item.wrap(this));</span>
    }

    /**
     * Obtains a single {@link GHDeployment} by its ID.
     *
     * @param id
     *            the id
     * @return the deployment
     * @throws IOException
     *             the io exception
     */
    public GHDeployment getDeployment(long id) throws IOException {
<span class="fc" id="L204">        return root().createRequest()</span>
<span class="fc" id="L205">                .withUrlPath(getApiTailUrl(&quot;deployments/&quot; + id))</span>
<span class="fc" id="L206">                .fetch(GHDeployment.class)</span>
<span class="fc" id="L207">                .wrap(this);</span>
    }

    /**
     * Gets deploy status.
     *
     * @param deploymentId
     *            the deployment id
     * @param ghDeploymentState
     *            the gh deployment state
     * @return the deploy status
     * @throws IOException
     *             the io exception
     * @deprecated Use {@code getDeployment(deploymentId).createStatus(ghDeploymentState)}
     */
    @Deprecated
    public GHDeploymentStatusBuilder createDeployStatus(int deploymentId, GHDeploymentState ghDeploymentState)
            throws IOException {
<span class="nc" id="L225">        return getDeployment(deploymentId).createStatus(ghDeploymentState);</span>
    }

<span class="fc" id="L228">    static class GHRepoPermission {</span>
        boolean pull, push, admin;
    }

    /**
     * Gets node id.
     *
     * @return the node id
     */
    public String getNodeId() {
<span class="fc" id="L238">        return nodeId;</span>
    }

    /**
     * Gets description.
     *
     * @return the description
     */
    public String getDescription() {
<span class="fc" id="L247">        return description;</span>
    }

    /**
     * Gets homepage.
     *
     * @return the homepage
     */
    public String getHomepage() {
<span class="fc" id="L256">        return homepage;</span>
    }

    /**
     * Gets the git:// URL to this repository, such as &quot;git://github.com/kohsuke/jenkins.git&quot; This URL is read-only.
     *
     * @return the git transport url
     */
    public String getGitTransportUrl() {
<span class="nc" id="L265">        return git_url;</span>
    }

    /**
     * Gets the HTTPS URL to this repository, such as &quot;https://github.com/kohsuke/jenkins.git&quot; This URL is read-only.
     *
     * @return the http transport url
     */
    public String getHttpTransportUrl() {
<span class="fc" id="L274">        return clone_url;</span>
    }

    /**
     * Git http transport url string.
     *
     * @return the string
     * @deprecated Typo of {@link #getHttpTransportUrl()}
     */
    @Deprecated
    public String gitHttpTransportUrl() {
<span class="fc" id="L285">        return clone_url;</span>
    }

    /**
     * Gets the Subversion URL to access this repository: https://github.com/rails/rails
     *
     * @return the svn url
     */
    public String getSvnUrl() {
<span class="nc" id="L294">        return svn_url;</span>
    }

    /**
     * Gets the Mirror URL to access this repository: https://github.com/apache/tomee mirrored from
     * git://git.apache.org/tomee.git
     *
     * @return the mirror url
     */
    public String getMirrorUrl() {
<span class="nc" id="L304">        return mirror_url;</span>
    }

    /**
     * Gets the SSH URL to access this repository, such as git@github.com:rails/rails.git
     *
     * @return the ssh url
     */
    public String getSshUrl() {
<span class="nc" id="L313">        return ssh_url;</span>
    }

    /**
     * Gets the html url.
     *
     * @return the html url
     */
    public URL getHtmlUrl() {
<span class="nc" id="L322">        return GitHubClient.parseURL(html_url);</span>
    }

    /**
     * Short repository name without the owner. For example 'jenkins' in case of http://github.com/jenkinsci/jenkins
     *
     * @return the name
     */
    public String getName() {
<span class="fc" id="L331">        return name;</span>
    }

    /**
     * Full repository name including the owner or organization. For example 'jenkinsci/jenkins' in case of
     * http://github.com/jenkinsci/jenkins
     *
     * @return the full name
     */
    public String getFullName() {
<span class="fc" id="L341">        return full_name;</span>
    }

    /**
     * Has pull access boolean.
     *
     * @return the boolean
     */
    public boolean hasPullAccess() {
<span class="pc bpc" id="L350" title="2 of 4 branches missed.">        return permissions != null &amp;&amp; permissions.pull;</span>
    }

    /**
     * Has push access boolean.
     *
     * @return the boolean
     */
    public boolean hasPushAccess() {
<span class="pc bpc" id="L359" title="2 of 4 branches missed.">        return permissions != null &amp;&amp; permissions.push;</span>
    }

    /**
     * Has admin access boolean.
     *
     * @return the boolean
     */
    public boolean hasAdminAccess() {
<span class="pc bpc" id="L368" title="2 of 4 branches missed.">        return permissions != null &amp;&amp; permissions.admin;</span>
    }

    /**
     * Gets the primary programming language.
     *
     * @return the language
     */
    public String getLanguage() {
<span class="fc" id="L377">        return language;</span>
    }

    /**
     * Gets owner.
     *
     * @return the owner
     * @throws IOException
     *             the io exception
     */
    @SuppressFBWarnings(value = { &quot;EI_EXPOSE_REP&quot; }, justification = &quot;Expected behavior&quot;)
    public GHUser getOwner() throws IOException {
<span class="fc bfc" id="L389" title="All 2 branches covered.">        return isOffline() ? owner : root().getUser(getOwnerName()); // because 'owner' isn't fully populated</span>
    }

    /**
     * Gets issue.
     *
     * @param id
     *            the id
     * @return the issue
     * @throws IOException
     *             the io exception
     */
    public GHIssue getIssue(int id) throws IOException {
<span class="fc" id="L402">        return root().createRequest().withUrlPath(getApiTailUrl(&quot;issues/&quot; + id)).fetch(GHIssue.class).wrap(this);</span>
    }

    /**
     * Create issue gh issue builder.
     *
     * @param title
     *            the title
     * @return the gh issue builder
     */
    public GHIssueBuilder createIssue(String title) {
<span class="fc" id="L413">        return new GHIssueBuilder(this, title);</span>
    }

    /**
     * Gets issues.
     *
     * @param state
     *            the state
     * @return the issues
     * @throws IOException
     *             the io exception
     */
    public List&lt;GHIssue&gt; getIssues(GHIssueState state) throws IOException {
<span class="fc" id="L426">        return queryIssues().state(state).list().toList();</span>
    }

    /**
     * Gets issues.
     *
     * @param state
     *            the state
     * @param milestone
     *            the milestone
     * @return the issues
     * @throws IOException
     *             the io exception
     */
    public List&lt;GHIssue&gt; getIssues(GHIssueState state, GHMilestone milestone) throws IOException {
<span class="nc bnc" id="L441" title="All 2 branches missed.">        return queryIssues().milestone(milestone == null ? &quot;none&quot; : &quot;&quot; + milestone.getNumber())</span>
<span class="nc" id="L442">                .state(state)</span>
<span class="nc" id="L443">                .list()</span>
<span class="nc" id="L444">                .toList();</span>
    }

    /**
     * Lists up all the issues in this repository.
     *
     * @param state
     *            the state
     * @return the paged iterable
     * @deprecated Use {@link #queryIssues()}
     */
    @Deprecated
    public PagedIterable&lt;GHIssue&gt; listIssues(final GHIssueState state) {
<span class="fc" id="L457">        return queryIssues().state(state).list();</span>
    }

    /**
     * Retrieves issues.
     *
     * @return the gh issue query builder
     */
    public GHIssueQueryBuilder.ForRepository queryIssues() {
<span class="fc" id="L466">        return new GHIssueQueryBuilder.ForRepository(this);</span>
    }

    /**
     * Create release gh release builder.
     *
     * @param tag
     *            the tag
     * @return the gh release builder
     */
    public GHReleaseBuilder createRelease(String tag) {
<span class="fc" id="L477">        return new GHReleaseBuilder(this, tag);</span>
    }

    /**
     * Creates a named ref, such as tag, branch, etc.
     *
     * @param name
     *            The name of the fully qualified reference (ie: refs/heads/main). If it doesn't start with 'refs' and
     *            have at least two slashes, it will be rejected.
     * @param sha
     *            The SHA1 value to set this reference to
     * @return the gh ref
     * @throws IOException
     *             the io exception
     */
    public GHRef createRef(String name, String sha) throws IOException {
<span class="fc" id="L493">        return root().createRequest()</span>
<span class="fc" id="L494">                .method(&quot;POST&quot;)</span>
<span class="fc" id="L495">                .with(&quot;ref&quot;, name)</span>
<span class="fc" id="L496">                .with(&quot;sha&quot;, sha)</span>
<span class="fc" id="L497">                .withUrlPath(getApiTailUrl(&quot;git/refs&quot;))</span>
<span class="fc" id="L498">                .fetch(GHRef.class);</span>
    }

    /**
     * Gets releases.
     *
     * @return the releases
     * @throws IOException
     *             the io exception
     * @deprecated use {@link #listReleases()}
     */
    public List&lt;GHRelease&gt; getReleases() throws IOException {
<span class="fc" id="L510">        return listReleases().toList();</span>
    }

    /**
     * Gets release.
     *
     * @param id
     *            the id
     * @return the release
     * @throws IOException
     *             the io exception
     */
    public GHRelease getRelease(long id) throws IOException {
        try {
<span class="fc" id="L524">            return root().createRequest()</span>
<span class="fc" id="L525">                    .withUrlPath(getApiTailUrl(&quot;releases/&quot; + id))</span>
<span class="fc" id="L526">                    .fetch(GHRelease.class)</span>
<span class="fc" id="L527">                    .wrap(this);</span>
<span class="fc" id="L528">        } catch (FileNotFoundException e) {</span>
<span class="fc" id="L529">            return null; // no release for this id</span>
        }
    }

    /**
     * Gets release by tag name.
     *
     * @param tag
     *            the tag
     * @return the release by tag name
     * @throws IOException
     *             the io exception
     */
    public GHRelease getReleaseByTagName(String tag) throws IOException {
        try {
<span class="fc" id="L544">            return root().createRequest()</span>
<span class="fc" id="L545">                    .withUrlPath(getApiTailUrl(&quot;releases/tags/&quot; + tag))</span>
<span class="fc" id="L546">                    .fetch(GHRelease.class)</span>
<span class="fc" id="L547">                    .wrap(this);</span>
<span class="fc" id="L548">        } catch (FileNotFoundException e) {</span>
<span class="fc" id="L549">            return null; // no release for this tag</span>
        }
    }

    /**
     * Gets latest release.
     *
     * @return the latest release
     * @throws IOException
     *             the io exception
     */
    public GHRelease getLatestRelease() throws IOException {
        try {
<span class="fc" id="L562">            return root().createRequest()</span>
<span class="fc" id="L563">                    .withUrlPath(getApiTailUrl(&quot;releases/latest&quot;))</span>
<span class="fc" id="L564">                    .fetch(GHRelease.class)</span>
<span class="fc" id="L565">                    .wrap(this);</span>
<span class="fc" id="L566">        } catch (FileNotFoundException e) {</span>
<span class="fc" id="L567">            return null; // no latest release</span>
        }
    }

    /**
     * List releases paged iterable.
     *
     * @return the paged iterable
     * @throws IOException
     *             the io exception
     */
    public PagedIterable&lt;GHRelease&gt; listReleases() throws IOException {
<span class="fc" id="L579">        return root().createRequest()</span>
<span class="fc" id="L580">                .withUrlPath(getApiTailUrl(&quot;releases&quot;))</span>
<span class="fc" id="L581">                .toIterable(GHRelease[].class, item -&gt; item.wrap(this));</span>
    }

    /**
     * List tags paged iterable.
     *
     * @return the paged iterable
     * @throws IOException
     *             the io exception
     */
    public PagedIterable&lt;GHTag&gt; listTags() throws IOException {
<span class="fc" id="L592">        return root().createRequest()</span>
<span class="fc" id="L593">                .withUrlPath(getApiTailUrl(&quot;tags&quot;))</span>
<span class="fc" id="L594">                .toIterable(GHTag[].class, item -&gt; item.wrap(this));</span>
    }

    /**
     * List languages for the specified repository. The value on the right of a language is the number of bytes of code
     * written in that language. { &quot;C&quot;: 78769, &quot;Python&quot;: 7769 }
     *
     * @return the map
     * @throws IOException
     *             the io exception
     */
    public Map&lt;String, Long&gt; listLanguages() throws IOException {
<span class="fc" id="L606">        HashMap&lt;String, Long&gt; result = new HashMap&lt;&gt;();</span>
<span class="fc" id="L607">        root().createRequest().withUrlPath(getApiTailUrl(&quot;languages&quot;)).fetch(HashMap.class).forEach((key, value) -&gt; {</span>
<span class="fc" id="L608">            Long addValue = -1L;</span>
<span class="pc bpc" id="L609" title="1 of 2 branches missed.">            if (value instanceof Integer) {</span>
<span class="fc" id="L610">                addValue = Long.valueOf((Integer) value);</span>
            }
<span class="fc" id="L612">            result.put(key.toString(), addValue);</span>
<span class="fc" id="L613">        });</span>
<span class="fc" id="L614">        return result;</span>
    }

    /**
     * Gets owner name.
     *
     * @return the owner name
     */
    public String getOwnerName() {
        // consistency of the GitHub API is super... some serialized forms of GHRepository populate
        // a full GHUser while others populate only the owner and email. This later form is super helpful
        // in putting the login in owner.name not owner.login... thankfully we can easily identify this
        // second set because owner.login will be null
<span class="fc bfc" id="L627" title="All 2 branches covered.">        return owner.login != null ? owner.login : owner.name;</span>
    }

    /**
     * Has issues boolean.
     *
     * @return the boolean
     */
    public boolean hasIssues() {
<span class="fc" id="L636">        return has_issues;</span>
    }

    /**
     * Has projects boolean.
     *
     * @return the boolean
     */
    public boolean hasProjects() {
<span class="fc" id="L645">        return has_projects;</span>
    }

    /**
     * Has wiki boolean.
     *
     * @return the boolean
     */
    public boolean hasWiki() {
<span class="fc" id="L654">        return has_wiki;</span>
    }

    /**
     * Is fork boolean.
     *
     * @return the boolean
     */
    public boolean isFork() {
<span class="fc" id="L663">        return fork;</span>
    }

    /**
     * Is archived boolean.
     *
     * @return the boolean
     */
    public boolean isArchived() {
<span class="fc" id="L672">        return archived;</span>
    }

    /**
     * Is disabled boolean.
     *
     * @return the boolean
     */
    public boolean isDisabled() {
<span class="fc" id="L681">        return disabled;</span>
    }

    /**
     * Is allow squash merge boolean.
     *
     * @return the boolean
     */
    public boolean isAllowSquashMerge() {
<span class="fc" id="L690">        return allow_squash_merge;</span>
    }

    /**
     * Is allow merge commit boolean.
     *
     * @return the boolean
     */
    public boolean isAllowMergeCommit() {
<span class="fc" id="L699">        return allow_merge_commit;</span>
    }

    /**
     * Is allow rebase merge boolean.
     *
     * @return the boolean
     */
    public boolean isAllowRebaseMerge() {
<span class="fc" id="L708">        return allow_rebase_merge;</span>
    }

    /**
     * Is allow private forks
     *
     * @return the boolean
     */
    public boolean isAllowForking() {
<span class="fc" id="L717">        return allow_forking;</span>
    }

    /**
     * Automatically deleting head branches when pull requests are merged.
     *
     * @return the boolean
     */
    public boolean isDeleteBranchOnMerge() {
<span class="fc" id="L726">        return delete_branch_on_merge;</span>
    }

    /**
     * Returns the number of all forks of this repository. This not only counts direct forks, but also forks of forks,
     * and so on.
     *
     * @return the forks
     * @deprecated use {@link #getForksCount()} instead
     */
    @Deprecated
    public int getForks() {
<span class="nc" id="L738">        return getForksCount();</span>
    }

    /**
     * Returns the number of all forks of this repository. This not only counts direct forks, but also forks of forks,
     * and so on.
     *
     * @return the forks
     */
    public int getForksCount() {
<span class="nc" id="L748">        return forks_count;</span>
    }

    /**
     * Gets stargazers count.
     *
     * @return the stargazers count
     */
    public int getStargazersCount() {
<span class="fc" id="L757">        return stargazers_count;</span>
    }

    /**
     * Is private boolean.
     *
     * @return the boolean
     */
    public boolean isPrivate() {
<span class="fc" id="L766">        return _private;</span>
    }

    /**
     * Visibility of a repository.
     */
<span class="fc" id="L772">    public enum Visibility {</span>

        /** The public. */
<span class="fc" id="L775">        PUBLIC,</span>

        /** The internal. */
<span class="fc" id="L778">        INTERNAL,</span>

        /** The private. */
<span class="fc" id="L781">        PRIVATE,</span>

        /**
         * Placeholder for unexpected data values.
         *
         * This avoids throwing exceptions during data binding or reading when the list of allowed values returned from
         * GitHub is expanded.
         *
         * Do not pass this value to any methods. If this value is returned during a request, check the log output and
         * report an issue for the missing value.
         */
<span class="fc" id="L792">        UNKNOWN;</span>

        /**
         * From.
         *
         * @param value
         *            the value
         * @return the visibility
         */
        public static Visibility from(String value) {
<span class="fc" id="L802">            return EnumUtils.getNullableEnumOrDefault(Visibility.class, value, Visibility.UNKNOWN);</span>
        }

        /**
         * To string.
         *
         * @return the string
         */
        @Override
        public String toString() {
<span class="fc" id="L812">            return name().toLowerCase(Locale.ROOT);</span>
        }
    }

    /**
     * Gets the visibility of the repository.
     *
     * @return the visibility
     */
    public Visibility getVisibility() {
<span class="fc bfc" id="L822" title="All 2 branches covered.">        if (visibility == null) {</span>
            try {
<span class="fc" id="L824">                populate();</span>
<span class="nc" id="L825">            } catch (final IOException e) {</span>
                // Convert this to a runtime exception to avoid messy method signature
<span class="nc" id="L827">                throw new GHException(&quot;Could not populate the visibility of the repository&quot;, e);</span>
<span class="fc" id="L828">            }</span>
        }
<span class="fc" id="L830">        return Visibility.from(visibility);</span>
    }

    /**
     * Is template boolean.
     *
     * @return the boolean
     */
    public boolean isTemplate() {
        // isTemplate is still in preview, we do not want to retrieve it unless needed.
<span class="pc bpc" id="L840" title="1 of 2 branches missed.">        if (isTemplate == null) {</span>
            try {
<span class="nc" id="L842">                populate();</span>
<span class="nc" id="L843">            } catch (IOException e) {</span>
                // Convert this to a runtime exception to avoid messy method signature
<span class="nc" id="L845">                throw new GHException(&quot;Could not populate the template setting of the repository&quot;, e);</span>
<span class="nc" id="L846">            }</span>
            // if this somehow is not populated, set it to false;
<span class="nc" id="L848">            isTemplate = Boolean.TRUE.equals(isTemplate);</span>
        }
<span class="fc" id="L850">        return isTemplate;</span>
    }

    /**
     * Has downloads boolean.
     *
     * @return the boolean
     */
    public boolean hasDownloads() {
<span class="fc" id="L859">        return has_downloads;</span>
    }

    /**
     * Has pages boolean.
     *
     * @return the boolean
     */
    public boolean hasPages() {
<span class="fc" id="L868">        return has_pages;</span>
    }

    /**
     * Gets watchers.
     *
     * @return the watchers
     * @deprecated use {@link #getWatchersCount()} instead
     */
    @Deprecated
    public int getWatchers() {
<span class="nc" id="L879">        return getWatchersCount();</span>
    }

    /**
     * Gets the count of watchers.
     *
     * @return the watchers
     */
    public int getWatchersCount() {
<span class="fc" id="L888">        return watchers_count;</span>
    }

    /**
     * Gets open issue count.
     *
     * @return the open issue count
     */
    public int getOpenIssueCount() {
<span class="nc" id="L897">        return open_issues_count;</span>
    }

    /**
     * Gets subscribers count.
     *
     * @return the subscribers count
     */
    public int getSubscribersCount() {
<span class="nc" id="L906">        return subscribers_count;</span>
    }

    /**
     * Gets pushed at.
     *
     * @return null if the repository was never pushed at.
     */
    public Date getPushedAt() {
<span class="nc" id="L915">        return GitHubClient.parseDate(pushed_at);</span>
    }

    /**
     * Returns the primary branch you'll configure in the &quot;Admin &amp;gt; Options&quot; config page.
     *
     * @return This field is null until the user explicitly configures the default branch.
     */
    public String getDefaultBranch() {
<span class="nc" id="L924">        return default_branch;</span>
    }

    /**
     * Gets default branch.
     *
     * Name is an artifact of when &quot;master&quot; was the most common default.
     *
     * @return the default branch
     * @deprecated Renamed to {@link #getDefaultBranch()}
     */
    @Deprecated
    public String getMasterBranch() {
<span class="nc" id="L937">        return default_branch;</span>
    }

    /**
     * Get Repository template was the repository created from.
     *
     * @return the repository template
     */
    @SuppressFBWarnings(value = { &quot;EI_EXPOSE_REP&quot; }, justification = &quot;Expected&quot;)
    public GHRepository getTemplateRepository() {
<span class="fc" id="L947">        return (GHRepository) template_repository;</span>
    }

    /**
     * Gets size.
     *
     * @return the size
     */
    public int getSize() {
<span class="nc" id="L956">        return size;</span>
    }

    /**
     * Affiliation of a repository collaborator.
     */
<span class="fc" id="L962">    public enum CollaboratorAffiliation {</span>

        /** The all. */
<span class="fc" id="L965">        ALL,</span>
        /** The direct. */
<span class="fc" id="L967">        DIRECT,</span>
        /** The outside. */
<span class="fc" id="L969">        OUTSIDE</span>
    }

    /**
     * Gets the collaborators on this repository. This set always appear to include the owner.
     *
     * @return the collaborators
     * @throws IOException
     *             the io exception
     */
    @WithBridgeMethods(Set.class)
    public GHPersonSet&lt;GHUser&gt; getCollaborators() throws IOException {
<span class="fc" id="L981">        return new GHPersonSet&lt;GHUser&gt;(listCollaborators().toList());</span>
    }

    /**
     * Lists up the collaborators on this repository.
     *
     * @return Users paged iterable
     * @throws IOException
     *             the io exception
     */
    public PagedIterable&lt;GHUser&gt; listCollaborators() throws IOException {
<span class="fc" id="L992">        return listUsers(&quot;collaborators&quot;);</span>
    }

    /**
     * Lists up the collaborators on this repository.
     *
     * @param affiliation
     *            Filter users by affiliation
     * @return Users paged iterable
     * @throws IOException
     *             the io exception
     */
    public PagedIterable&lt;GHUser&gt; listCollaborators(CollaboratorAffiliation affiliation) throws IOException {
<span class="fc" id="L1005">        return listUsers(root().createRequest().with(&quot;affiliation&quot;, affiliation), &quot;collaborators&quot;);</span>
    }

    /**
     * Lists all
     * &lt;a href= &quot;https://help.github.com/articles/assigning-issues-and-pull-requests-to-other-github-users/&quot;&gt;the
     * available assignees&lt;/a&gt; to which issues may be assigned.
     *
     * @return the paged iterable
     * @throws IOException
     *             the io exception
     */
    public PagedIterable&lt;GHUser&gt; listAssignees() throws IOException {
<span class="nc" id="L1018">        return listUsers(&quot;assignees&quot;);</span>
    }

    /**
     * Checks if the given user is an assignee for this repository.
     *
     * @param u
     *            the u
     * @return the boolean
     * @throws IOException
     *             the io exception
     */
    public boolean hasAssignee(GHUser u) throws IOException {
<span class="nc bnc" id="L1031" title="All 2 branches missed.">        return root().createRequest().withUrlPath(getApiTailUrl(&quot;assignees/&quot; + u.getLogin())).fetchHttpStatusCode()</span>
                / 100 == 2;
    }

    /**
     * Gets the names of the collaborators on this repository. This method deviates from the principle of this library
     * but it works a lot faster than {@link #getCollaborators()}.
     *
     * @return the collaborator names
     * @throws IOException
     *             the io exception
     */
    public Set&lt;String&gt; getCollaboratorNames() throws IOException {
<span class="fc" id="L1044">        Set&lt;String&gt; r = new HashSet&lt;&gt;();</span>
        // no initializer - we just want to the logins
<span class="fc" id="L1046">        PagedIterable&lt;GHUser&gt; users = root().createRequest()</span>
<span class="fc" id="L1047">                .withUrlPath(getApiTailUrl(&quot;collaborators&quot;))</span>
<span class="fc" id="L1048">                .toIterable(GHUser[].class, null);</span>
<span class="fc bfc" id="L1049" title="All 2 branches covered.">        for (GHUser u : users.toArray()) {</span>
<span class="fc" id="L1050">            r.add(u.login);</span>
        }
<span class="fc" id="L1052">        return r;</span>
    }

    /**
     * Gets the names of the collaborators on this repository. This method deviates from the principle of this library
     * but it works a lot faster than {@link #getCollaborators()}.
     *
     * @param affiliation
     *            Filter users by affiliation
     * @return the collaborator names
     * @throws IOException
     *             the io exception
     */
    public Set&lt;String&gt; getCollaboratorNames(CollaboratorAffiliation affiliation) throws IOException {
<span class="nc" id="L1066">        Set&lt;String&gt; r = new HashSet&lt;&gt;();</span>
        // no initializer - we just want to the logins
<span class="nc" id="L1068">        PagedIterable&lt;GHUser&gt; users = root().createRequest()</span>
<span class="nc" id="L1069">                .withUrlPath(getApiTailUrl(&quot;collaborators&quot;))</span>
<span class="nc" id="L1070">                .with(&quot;affiliation&quot;, affiliation)</span>
<span class="nc" id="L1071">                .toIterable(GHUser[].class, null);</span>
<span class="nc bnc" id="L1072" title="All 2 branches missed.">        for (GHUser u : users.toArray()) {</span>
<span class="nc" id="L1073">            r.add(u.login);</span>
        }
<span class="nc" id="L1075">        return r;</span>
    }

    /**
     * Checks if the given user is a collaborator for this repository.
     *
     * @param user
     *            a {@link GHUser}
     * @return true if the user is a collaborator for this repository
     * @throws IOException
     *             the io exception
     */
    public boolean isCollaborator(GHUser user) throws IOException {
<span class="fc" id="L1088">        return root().createRequest()</span>
<span class="fc" id="L1089">                .withUrlPath(getApiTailUrl(&quot;collaborators/&quot; + user.getLogin()))</span>
<span class="pc bpc" id="L1090" title="1 of 2 branches missed.">                .fetchHttpStatusCode() == 204;</span>
    }

    /**
     * Obtain permission for a given user in this repository.
     *
     * @param user
     *            a {@link GHUser#getLogin}
     * @return the permission
     * @throws IOException
     *             the io exception
     */
    public GHPermissionType getPermission(String user) throws IOException {
<span class="fc" id="L1103">        GHPermission perm = root().createRequest()</span>
<span class="fc" id="L1104">                .withUrlPath(getApiTailUrl(&quot;collaborators/&quot; + user + &quot;/permission&quot;))</span>
<span class="fc" id="L1105">                .fetch(GHPermission.class);</span>
<span class="fc" id="L1106">        return perm.getPermissionType();</span>
    }

    /**
     * Obtain permission for a given user in this repository.
     *
     * @param u
     *            the user
     * @return the permission
     * @throws IOException
     *             the io exception
     */
    public GHPermissionType getPermission(GHUser u) throws IOException {
<span class="nc" id="L1119">        return getPermission(u.getLogin());</span>
    }

    /**
     * Check if a user has at least the given permission in this repository.
     *
     * @param user
     *            a {@link GHUser#getLogin}
     * @param permission
     *            the permission to check
     * @return true if the user has at least this permission level
     * @throws IOException
     *             the io exception
     */
    public boolean hasPermission(String user, GHPermissionType permission) throws IOException {
<span class="fc" id="L1134">        return getPermission(user).implies(permission);</span>
    }

    /**
     * Check if a user has at least the given permission in this repository.
     *
     * @param user
     *            the user
     * @param permission
     *            the permission to check
     * @return true if the user has at least this permission level
     * @throws IOException
     *             the io exception
     */
    public boolean hasPermission(GHUser user, GHPermissionType permission) throws IOException {
<span class="fc" id="L1149">        return hasPermission(user.getLogin(), permission);</span>
    }

    /**
     * If this repository belongs to an organization, return a set of teams.
     *
     * @return the teams
     * @throws IOException
     *             the io exception
     */
    public Set&lt;GHTeam&gt; getTeams() throws IOException {
<span class="fc" id="L1160">        GHOrganization org = root().getOrganization(getOwnerName());</span>
<span class="fc" id="L1161">        return root().createRequest()</span>
<span class="fc" id="L1162">                .withUrlPath(getApiTailUrl(&quot;teams&quot;))</span>
<span class="fc" id="L1163">                .toIterable(GHTeam[].class, item -&gt; item.wrapUp(org))</span>
<span class="fc" id="L1164">                .toSet();</span>
    }

    /**
     * Add collaborators.
     *
     * @param permission
     *            the permission level
     * @param users
     *            the users
     * @throws IOException
     *             the io exception
     * @deprecated #addCollaborators(GHOrganization.RolePermission, GHUser)
     */
    @Deprecated
    public void addCollaborators(GHOrganization.Permission permission, GHUser... users) throws IOException {
<span class="nc" id="L1180">        addCollaborators(asList(users), permission);</span>
<span class="nc" id="L1181">    }</span>

    /**
     * Add collaborators.
     *
     * @param permission
     *            the permission level
     * @param users
     *            the users
     *
     * @throws IOException
     *             the io exception
     */
    public void addCollaborators(GHOrganization.RepositoryRole permission, GHUser... users) throws IOException {
<span class="fc" id="L1195">        addCollaborators(asList(users), permission);</span>
<span class="fc" id="L1196">    }</span>

    /**
     * Add collaborators.
     *
     * @param users
     *            the users
     * @throws IOException
     *             the io exception
     */
    public void addCollaborators(GHUser... users) throws IOException {
<span class="nc" id="L1207">        addCollaborators(asList(users));</span>
<span class="nc" id="L1208">    }</span>

    /**
     * Add collaborators.
     *
     * @param users
     *            the users
     * @throws IOException
     *             the io exception
     */
    public void addCollaborators(Collection&lt;GHUser&gt; users) throws IOException {
<span class="nc" id="L1219">        modifyCollaborators(users, &quot;PUT&quot;, null);</span>
<span class="nc" id="L1220">    }</span>

    /**
     * Add collaborators.
     *
     * @param users
     *            the users
     * @param permission
     *            the permission level
     * @throws IOException
     *             the io exception
     * @deprecated #addCollaborators(Collection, GHOrganization.RolePermission)
     */
    @Deprecated
    public void addCollaborators(Collection&lt;GHUser&gt; users, GHOrganization.Permission permission) throws IOException {
<span class="fc" id="L1235">        modifyCollaborators(users, &quot;PUT&quot;, GHOrganization.RepositoryRole.from(permission));</span>
<span class="fc" id="L1236">    }</span>

    /**
     * Add collaborators.
     *
     * @param users
     *            the users
     * @param permission
     *            the permission level
     * @throws IOException
     *             the io exception
     */
    public void addCollaborators(Collection&lt;GHUser&gt; users, GHOrganization.RepositoryRole permission)
            throws IOException {
<span class="fc" id="L1250">        modifyCollaborators(users, &quot;PUT&quot;, permission);</span>
<span class="fc" id="L1251">    }</span>

    /**
     * Remove collaborators.
     *
     * @param users
     *            the users
     * @throws IOException
     *             the io exception
     */
    public void removeCollaborators(GHUser... users) throws IOException {
<span class="nc" id="L1262">        removeCollaborators(asList(users));</span>
<span class="nc" id="L1263">    }</span>

    /**
     * Remove collaborators.
     *
     * @param users
     *            the users
     * @throws IOException
     *             the io exception
     */
    public void removeCollaborators(Collection&lt;GHUser&gt; users) throws IOException {
<span class="nc" id="L1274">        modifyCollaborators(users, &quot;DELETE&quot;, null);</span>
<span class="nc" id="L1275">    }</span>

    private void modifyCollaborators(@NonNull Collection&lt;GHUser&gt; users,
            @NonNull String method,
            @CheckForNull GHOrganization.RepositoryRole permission) throws IOException {
<span class="fc" id="L1280">        Requester requester = root().createRequest().method(method);</span>
<span class="pc bpc" id="L1281" title="1 of 2 branches missed.">        if (permission != null) {</span>
<span class="fc" id="L1282">            requester = requester.with(&quot;permission&quot;, permission.toString()).inBody();</span>
        }

        // Make sure that the users collection doesn't have any duplicates
<span class="fc bfc" id="L1286" title="All 2 branches covered.">        for (GHUser user : new LinkedHashSet&lt;&gt;(users)) {</span>
<span class="fc" id="L1287">            requester.withUrlPath(getApiTailUrl(&quot;collaborators/&quot; + user.getLogin())).send();</span>
<span class="fc" id="L1288">        }</span>
<span class="fc" id="L1289">    }</span>

    /**
     * Sets email service hook.
     *
     * @param address
     *            the address
     * @throws IOException
     *             the io exception
     */
    public void setEmailServiceHook(String address) throws IOException {
<span class="nc" id="L1300">        Map&lt;String, String&gt; config = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1301">        config.put(&quot;address&quot;, address);</span>
<span class="nc" id="L1302">        root().createRequest()</span>
<span class="nc" id="L1303">                .method(&quot;POST&quot;)</span>
<span class="nc" id="L1304">                .with(&quot;name&quot;, &quot;email&quot;)</span>
<span class="nc" id="L1305">                .with(&quot;config&quot;, config)</span>
<span class="nc" id="L1306">                .with(&quot;active&quot;, true)</span>
<span class="nc" id="L1307">                .withUrlPath(getApiTailUrl(&quot;hooks&quot;))</span>
<span class="nc" id="L1308">                .send();</span>
<span class="nc" id="L1309">    }</span>

    /**
     * Enables or disables the issue tracker for this repository.
     *
     * @param v
     *            the v
     * @throws IOException
     *             the io exception
     */
    public void enableIssueTracker(boolean v) throws IOException {
<span class="fc" id="L1320">        set().issues(v);</span>
<span class="fc" id="L1321">    }</span>

    /**
     * Enables or disables projects for this repository.
     *
     * @param v
     *            the v
     * @throws IOException
     *             the io exception
     */
    public void enableProjects(boolean v) throws IOException {
<span class="fc" id="L1332">        set().projects(v);</span>
<span class="fc" id="L1333">    }</span>

    /**
     * Enables or disables Wiki for this repository.
     *
     * @param v
     *            the v
     * @throws IOException
     *             the io exception
     */
    public void enableWiki(boolean v) throws IOException {
<span class="fc" id="L1344">        set().wiki(v);</span>
<span class="fc" id="L1345">    }</span>

    /**
     * Enable downloads.
     *
     * @param v
     *            the v
     * @throws IOException
     *             the io exception
     */
    public void enableDownloads(boolean v) throws IOException {
<span class="fc" id="L1356">        set().downloads(v);</span>
<span class="fc" id="L1357">    }</span>

    /**
     * Rename this repository.
     *
     * @param name
     *            the name
     * @throws IOException
     *             the io exception
     */
    public void renameTo(String name) throws IOException {
<span class="fc" id="L1368">        set().name(name);</span>
<span class="fc" id="L1369">    }</span>

    /**
     * Sets description.
     *
     * @param value
     *            the value
     * @throws IOException
     *             the io exception
     */
    public void setDescription(String value) throws IOException {
<span class="fc" id="L1380">        set().description(value);</span>
<span class="fc" id="L1381">    }</span>

    /**
     * Sets homepage.
     *
     * @param value
     *            the value
     * @throws IOException
     *             the io exception
     */
    public void setHomepage(String value) throws IOException {
<span class="nc" id="L1392">        set().homepage(value);</span>
<span class="nc" id="L1393">    }</span>

    /**
     * Sets default branch.
     *
     * @param value
     *            the value
     * @throws IOException
     *             the io exception
     */
    public void setDefaultBranch(String value) throws IOException {
<span class="nc" id="L1404">        set().defaultBranch(value);</span>
<span class="nc" id="L1405">    }</span>

    /**
     * Sets private.
     *
     * @param value
     *            the value
     * @throws IOException
     *             the io exception
     */
    public void setPrivate(boolean value) throws IOException {
<span class="fc" id="L1416">        set().private_(value);</span>
<span class="fc" id="L1417">    }</span>

    /**
     * Sets visibility.
     *
     * @param value
     *            the value
     * @throws IOException
     *             the io exception
     */
    public void setVisibility(final Visibility value) throws IOException {
<span class="fc" id="L1428">        root().createRequest()</span>
<span class="fc" id="L1429">                .method(&quot;PATCH&quot;)</span>
<span class="fc" id="L1430">                .with(&quot;name&quot;, name)</span>
<span class="fc" id="L1431">                .with(&quot;visibility&quot;, value)</span>
<span class="fc" id="L1432">                .withUrlPath(getApiTailUrl(&quot;&quot;))</span>
<span class="fc" id="L1433">                .send();</span>
<span class="fc" id="L1434">    }</span>

    /**
     * Allow squash merge.
     *
     * @param value
     *            the value
     * @throws IOException
     *             the io exception
     */
    public void allowSquashMerge(boolean value) throws IOException {
<span class="fc" id="L1445">        set().allowSquashMerge(value);</span>
<span class="fc" id="L1446">    }</span>

    /**
     * Allow merge commit.
     *
     * @param value
     *            the value
     * @throws IOException
     *             the io exception
     */
    public void allowMergeCommit(boolean value) throws IOException {
<span class="fc" id="L1457">        set().allowMergeCommit(value);</span>
<span class="fc" id="L1458">    }</span>

    /**
     * Allow rebase merge.
     *
     * @param value
     *            the value
     * @throws IOException
     *             the io exception
     */
    public void allowRebaseMerge(boolean value) throws IOException {
<span class="fc" id="L1469">        set().allowRebaseMerge(value);</span>
<span class="fc" id="L1470">    }</span>

    /**
     * Allow private fork.
     *
     * @param value
     *            the value
     * @throws IOException
     *             the io exception
     */
    public void allowForking(boolean value) throws IOException {
<span class="nc" id="L1481">        set().allowForking(value);</span>
<span class="nc" id="L1482">    }</span>

    /**
     * After pull requests are merged, you can have head branches deleted automatically.
     *
     * @param value
     *            the value
     * @throws IOException
     *             the io exception
     */
    public void deleteBranchOnMerge(boolean value) throws IOException {
<span class="fc" id="L1493">        set().deleteBranchOnMerge(value);</span>
<span class="fc" id="L1494">    }</span>

    /**
     * Deletes this repository.
     *
     * @throws IOException
     *             the io exception
     */
    public void delete() throws IOException {
        try {
<span class="fc" id="L1504">            root().createRequest().method(&quot;DELETE&quot;).withUrlPath(getApiTailUrl(&quot;&quot;)).send();</span>
<span class="nc" id="L1505">        } catch (FileNotFoundException x) {</span>
<span class="nc" id="L1506">            throw (FileNotFoundException) new FileNotFoundException(&quot;Failed to delete &quot; + getOwnerName() + &quot;/&quot; + name</span>
                    + &quot;; might not exist, or you might need the delete_repo scope in your token: http://stackoverflow.com/a/19327004/12916&quot;)
<span class="nc" id="L1508">                    .initCause(x);</span>
<span class="fc" id="L1509">        }</span>
<span class="fc" id="L1510">    }</span>

    /**
     * Will archive and this repository as read-only. When a repository is archived, any operation that can change its
     * state is forbidden. This applies symmetrically if trying to unarchive it.
     *
     * &lt;p&gt;
     * When you try to do any operation that modifies a read-only repository, it returns the response:
     *
     * &lt;pre&gt;
     * org.kohsuke.github.HttpException: {
     *     &quot;message&quot;:&quot;Repository was archived so is read-only.&quot;,
     *     &quot;documentation_url&quot;:&quot;https://developer.github.com/v3/repos/#edit&quot;
     * }
     * &lt;/pre&gt;
     *
     * @throws IOException
     *             In case of any networking error or error from the server.
     */
    public void archive() throws IOException {
<span class="fc" id="L1530">        set().archive();</span>
        // Generally would not update this record,
        // but doing so here since this will result in any other update actions failing
<span class="fc" id="L1533">        archived = true;</span>
<span class="fc" id="L1534">    }</span>

    /**
     * Creates a builder that can be used to bulk update repository settings.
     *
     * @return the repository updater
     */
    public Updater update() {
<span class="fc" id="L1542">        return new Updater(this);</span>
    }

    /**
     * Creates a builder that can be used to bulk update repository settings.
     *
     * @return the repository updater
     */
    public Setter set() {
<span class="fc" id="L1551">        return new Setter(this);</span>
    }

    /**
     * Sort orders for listing forks.
     */
<span class="fc" id="L1557">    public enum ForkSort {</span>

        /** The newest. */
<span class="fc" id="L1560">        NEWEST,</span>
        /** The oldest. */
<span class="fc" id="L1562">        OLDEST,</span>
        /** The stargazers. */
<span class="fc" id="L1564">        STARGAZERS</span>
    }

    /**
     * Lists all the direct forks of this repository, sorted by github api default, currently {@link ForkSort#NEWEST
     * ForkSort.NEWEST}*.
     *
     * @return the paged iterable
     */
    public PagedIterable&lt;GHRepository&gt; listForks() {
<span class="nc" id="L1574">        return listForks(null);</span>
    }

    /**
     * Lists all the direct forks of this repository, sorted by the given sort order.
     *
     * @param sort
     *            the sort order. If null, defaults to github api default, currently {@link ForkSort#NEWEST
     *            ForkSort.NEWEST}.
     * @return the paged iterable
     */
    public PagedIterable&lt;GHRepository&gt; listForks(final ForkSort sort) {
<span class="nc" id="L1586">        return root().createRequest()</span>
<span class="nc" id="L1587">                .with(&quot;sort&quot;, sort)</span>
<span class="nc" id="L1588">                .withUrlPath(getApiTailUrl(&quot;forks&quot;))</span>
<span class="nc" id="L1589">                .toIterable(GHRepository[].class, null);</span>
    }

    /**
     * Forks this repository as your repository.
     *
     * @return Newly forked repository that belong to you.
     * @throws IOException
     *             the io exception
     */
    public GHRepository fork() throws IOException {
<span class="nc" id="L1600">        root().createRequest().method(&quot;POST&quot;).withUrlPath(getApiTailUrl(&quot;forks&quot;)).send();</span>

        // this API is asynchronous. we need to wait for a bit
<span class="nc bnc" id="L1603" title="All 2 branches missed.">        for (int i = 0; i &lt; 10; i++) {</span>
<span class="nc" id="L1604">            GHRepository r = root().getMyself().getRepository(name);</span>
<span class="nc bnc" id="L1605" title="All 2 branches missed.">            if (r != null) {</span>
<span class="nc" id="L1606">                return r;</span>
            }
            try {
<span class="nc" id="L1609">                Thread.sleep(3000);</span>
<span class="nc" id="L1610">            } catch (InterruptedException e) {</span>
<span class="nc" id="L1611">                throw (IOException) new InterruptedIOException().initCause(e);</span>
<span class="nc" id="L1612">            }</span>
        }
<span class="nc" id="L1614">        throw new IOException(this + &quot; was forked but can't find the new repository&quot;);</span>
    }

    /**
     * Sync this repository fork branch
     *
     * @param branch
     *            the branch to sync
     * @return The current repository
     * @throws IOException
     *             the io exception
     */
    public GHBranchSync sync(String branch) throws IOException {
<span class="fc" id="L1627">        return root().createRequest()</span>
<span class="fc" id="L1628">                .method(&quot;POST&quot;)</span>
<span class="fc" id="L1629">                .with(&quot;branch&quot;, branch)</span>
<span class="fc" id="L1630">                .withUrlPath(getApiTailUrl(&quot;merge-upstream&quot;))</span>
<span class="fc" id="L1631">                .fetch(GHBranchSync.class)</span>
<span class="fc" id="L1632">                .wrap(this);</span>
    }

    /**
     * Forks this repository into an organization.
     *
     * @param org
     *            the org
     * @return Newly forked repository that belong to you.
     * @throws IOException
     *             the io exception
     */
    public GHRepository forkTo(GHOrganization org) throws IOException {
<span class="fc" id="L1645">        root().createRequest()</span>
<span class="fc" id="L1646">                .method(&quot;POST&quot;)</span>
<span class="fc" id="L1647">                .with(&quot;organization&quot;, org.getLogin())</span>
<span class="fc" id="L1648">                .withUrlPath(getApiTailUrl(&quot;forks&quot;))</span>
<span class="fc" id="L1649">                .send();</span>

        // this API is asynchronous. we need to wait for a bit
<span class="pc bpc" id="L1652" title="1 of 2 branches missed.">        for (int i = 0; i &lt; 10; i++) {</span>
<span class="fc" id="L1653">            GHRepository r = org.getRepository(name);</span>
<span class="pc bpc" id="L1654" title="1 of 2 branches missed.">            if (r != null) {</span>
<span class="fc" id="L1655">                return r;</span>
            }
            try {
<span class="nc" id="L1658">                Thread.sleep(3000);</span>
<span class="nc" id="L1659">            } catch (InterruptedException e) {</span>
<span class="nc" id="L1660">                throw (IOException) new InterruptedIOException().initCause(e);</span>
<span class="nc" id="L1661">            }</span>
        }
<span class="nc" id="L1663">        throw new IOException(this + &quot; was forked into &quot; + org.getLogin() + &quot; but can't find the new repository&quot;);</span>
    }

    /**
     * Retrieves a specified pull request.
     *
     * @param i
     *            the
     * @return the pull request
     * @throws IOException
     *             the io exception
     */
    public GHPullRequest getPullRequest(int i) throws IOException {
<span class="fc" id="L1676">        return root().createRequest().withUrlPath(getApiTailUrl(&quot;pulls/&quot; + i)).fetch(GHPullRequest.class).wrapUp(this);</span>
    }

    /**
     * Retrieves all the pull requests of a particular state.
     *
     * @param state
     *            the state
     * @return the pull requests
     * @throws IOException
     *             the io exception
     * @see #listPullRequests(GHIssueState) #listPullRequests(GHIssueState)
     */
    public List&lt;GHPullRequest&gt; getPullRequests(GHIssueState state) throws IOException {
<span class="nc" id="L1690">        return queryPullRequests().state(state).list().toList();</span>
    }

    /**
     * Retrieves all the pull requests of a particular state.
     *
     * @param state
     *            the state
     * @return the paged iterable
     * @deprecated Use {@link #queryPullRequests()}
     */
    @Deprecated
    public PagedIterable&lt;GHPullRequest&gt; listPullRequests(GHIssueState state) {
<span class="fc" id="L1703">        return queryPullRequests().state(state).list();</span>
    }

    /**
     * Retrieves pull requests.
     *
     * @return the gh pull request query builder
     */
    public GHPullRequestQueryBuilder queryPullRequests() {
<span class="fc" id="L1712">        return new GHPullRequestQueryBuilder(this);</span>
    }

    /**
     * Retrieves pull requests according to search terms.
     *
     * @return gh pull request search builder for current repository
     */
    public GHPullRequestSearchBuilder searchPullRequests() {
<span class="fc" id="L1721">        return new GHPullRequestSearchBuilder(this.root()).repo(this);</span>
    }

    /**
     * Creates a new pull request.
     *
     * @param title
     *            Required. The title of the pull request.
     * @param head
     *            Required. The name of the branch where your changes are implemented. For cross-repository pull
     *            requests in the same network, namespace head with a user like this: username:branch.
     * @param base
     *            Required. The name of the branch you want your changes pulled into. This should be an existing branch
     *            on the current repository.
     * @param body
     *            The contents of the pull request. This is the markdown description of a pull request.
     * @return the gh pull request
     * @throws IOException
     *             the io exception
     */
    public GHPullRequest createPullRequest(String title, String head, String base, String body) throws IOException {
<span class="fc" id="L1742">        return createPullRequest(title, head, base, body, true);</span>
    }

    /**
     * Creates a new pull request. Maintainer's permissions aware.
     *
     * @param title
     *            Required. The title of the pull request.
     * @param head
     *            Required. The name of the branch where your changes are implemented. For cross-repository pull
     *            requests in the same network, namespace head with a user like this: username:branch.
     * @param base
     *            Required. The name of the branch you want your changes pulled into. This should be an existing branch
     *            on the current repository.
     * @param body
     *            The contents of the pull request. This is the markdown description of a pull request.
     * @param maintainerCanModify
     *            Indicates whether maintainers can modify the pull request.
     * @return the gh pull request
     * @throws IOException
     *             the io exception
     */
    public GHPullRequest createPullRequest(String title,
            String head,
            String base,
            String body,
            boolean maintainerCanModify) throws IOException {
<span class="fc" id="L1769">        return createPullRequest(title, head, base, body, maintainerCanModify, false);</span>
    }

    /**
     * Creates a new pull request. Maintainer's permissions and draft aware.
     *
     * @param title
     *            Required. The title of the pull request.
     * @param head
     *            Required. The name of the branch where your changes are implemented. For cross-repository pull
     *            requests in the same network, namespace head with a user like this: username:branch.
     * @param base
     *            Required. The name of the branch you want your changes pulled into. This should be an existing branch
     *            on the current repository.
     * @param body
     *            The contents of the pull request. This is the markdown description of a pull request.
     * @param maintainerCanModify
     *            Indicates whether maintainers can modify the pull request.
     * @param draft
     *            Indicates whether to create a draft pull request or not.
     * @return the gh pull request
     * @throws IOException
     *             the io exception
     */
    public GHPullRequest createPullRequest(String title,
            String head,
            String base,
            String body,
            boolean maintainerCanModify,
            boolean draft) throws IOException {
<span class="fc" id="L1799">        return root().createRequest()</span>
<span class="fc" id="L1800">                .method(&quot;POST&quot;)</span>
<span class="fc" id="L1801">                .with(&quot;title&quot;, title)</span>
<span class="fc" id="L1802">                .with(&quot;head&quot;, head)</span>
<span class="fc" id="L1803">                .with(&quot;base&quot;, base)</span>
<span class="fc" id="L1804">                .with(&quot;body&quot;, body)</span>
<span class="fc" id="L1805">                .with(&quot;maintainer_can_modify&quot;, maintainerCanModify)</span>
<span class="fc" id="L1806">                .with(&quot;draft&quot;, draft)</span>
<span class="fc" id="L1807">                .withUrlPath(getApiTailUrl(&quot;pulls&quot;))</span>
<span class="fc" id="L1808">                .fetch(GHPullRequest.class)</span>
<span class="fc" id="L1809">                .wrapUp(this);</span>
    }

    /**
     * Retrieves the currently configured hooks.
     *
     * @return the hooks
     * @throws IOException
     *             the io exception
     */
    public List&lt;GHHook&gt; getHooks() throws IOException {
<span class="fc" id="L1820">        return GHHooks.repoContext(this, owner).getHooks();</span>
    }

    /**
     * Gets hook.
     *
     * @param id
     *            the id
     * @return the hook
     * @throws IOException
     *             the io exception
     */
    public GHHook getHook(int id) throws IOException {
<span class="fc" id="L1833">        return GHHooks.repoContext(this, owner).getHook(id);</span>
    }

    /**
     * Deletes hook.
     *
     * @param id
     *            the id
     * @throws IOException
     *             the io exception
     */
    public void deleteHook(int id) throws IOException {
<span class="fc" id="L1845">        GHHooks.repoContext(this, owner).deleteHook(id);</span>
<span class="fc" id="L1846">    }</span>

    /**
     * Sets {@link #getCompare(String, String)} to return a {@link GHCompare} that uses a paginated commit list instead
     * of limiting to 250 results.
     *
     * By default, {@link GHCompare} returns all commits in the comparison as part of the request, limited to 250
     * results. More recently GitHub added the ability to return the commits as a paginated query allowing for more than
     * 250 results.
     *
     * @param value
     *            true if you want commits returned in paginated form.
     */
    public void setCompareUsePaginatedCommits(boolean value) {
<span class="fc" id="L1860">        compareUsePaginatedCommits = value;</span>
<span class="fc" id="L1861">    }</span>

    /**
     * Gets a comparison between 2 points in the repository. This would be similar to calling
     * &lt;code&gt;git log id1...id2&lt;/code&gt; against a local repository.
     *
     * @param id1
     *            an identifier for the first point to compare from, this can be a sha1 ID (for a commit, tag etc) or a
     *            direct tag name
     * @param id2
     *            an identifier for the second point to compare to. Can be the same as the first point.
     * @return the comparison output
     * @throws IOException
     *             on failure communicating with GitHub
     */
    public GHCompare getCompare(String id1, String id2) throws IOException {
<span class="fc" id="L1877">        final Requester requester = root().createRequest()</span>
<span class="fc" id="L1878">                .withUrlPath(getApiTailUrl(String.format(&quot;compare/%s...%s&quot;, id1, id2)));</span>

<span class="fc bfc" id="L1880" title="All 2 branches covered.">        if (compareUsePaginatedCommits) {</span>
<span class="fc" id="L1881">            requester.with(&quot;per_page&quot;, 1).with(&quot;page&quot;, 1);</span>
        }
<span class="fc" id="L1883">        requester.injectMappingValue(&quot;GHCompare_usePaginatedCommits&quot;, compareUsePaginatedCommits);</span>
<span class="fc" id="L1884">        GHCompare compare = requester.fetch(GHCompare.class);</span>
<span class="fc" id="L1885">        return compare.lateBind(this);</span>
    }

    /**
     * Gets compare.
     *
     * @param id1
     *            the id 1
     * @param id2
     *            the id 2
     * @return the compare
     * @throws IOException
     *             the io exception
     */
    public GHCompare getCompare(GHCommit id1, GHCommit id2) throws IOException {
<span class="nc" id="L1900">        return getCompare(id1.getSHA1(), id2.getSHA1());</span>
    }

    /**
     * Gets compare.
     *
     * @param id1
     *            the id 1
     * @param id2
     *            the id 2
     * @return the compare
     * @throws IOException
     *             the io exception
     */
    public GHCompare getCompare(GHBranch id1, GHBranch id2) throws IOException {

<span class="nc" id="L1916">        GHRepository owner1 = id1.getOwner();</span>
<span class="nc" id="L1917">        GHRepository owner2 = id2.getOwner();</span>

        // If the owner of the branches is different, we have a cross-fork compare.
<span class="nc bnc" id="L1920" title="All 4 branches missed.">        if (owner1 != null &amp;&amp; owner2 != null) {</span>
<span class="nc" id="L1921">            String ownerName1 = owner1.getOwnerName();</span>
<span class="nc" id="L1922">            String ownerName2 = owner2.getOwnerName();</span>
<span class="nc bnc" id="L1923" title="All 2 branches missed.">            if (!StringUtils.equals(ownerName1, ownerName2)) {</span>
<span class="nc" id="L1924">                String qualifiedName1 = String.format(&quot;%s:%s&quot;, ownerName1, id1.getName());</span>
<span class="nc" id="L1925">                String qualifiedName2 = String.format(&quot;%s:%s&quot;, ownerName2, id2.getName());</span>
<span class="nc" id="L1926">                return getCompare(qualifiedName1, qualifiedName2);</span>
            }
        }

<span class="nc" id="L1930">        return getCompare(id1.getName(), id2.getName());</span>
    }

    /**
     * Retrieves all refs for the github repository.
     *
     * @return an array of GHRef elements corresponding with the refs in the remote repository.
     * @throws IOException
     *             on failure communicating with GitHub
     */
    public GHRef[] getRefs() throws IOException {
<span class="fc" id="L1941">        return listRefs().toArray();</span>
    }

    /**
     * Retrieves all refs for the github repository.
     *
     * @return paged iterable of all refs
     * @throws IOException
     *             on failure communicating with GitHub, potentially due to an invalid ref type being requested
     */
    public PagedIterable&lt;GHRef&gt; listRefs() throws IOException {
<span class="fc" id="L1952">        return listRefs(&quot;&quot;);</span>
    }

    /**
     * Retrieves all refs of the given type for the current GitHub repository.
     *
     * @param refType
     *            the type of reg to search for e.g. &lt;code&gt;tags&lt;/code&gt; or &lt;code&gt;commits&lt;/code&gt;
     * @return an array of all refs matching the request type
     * @throws IOException
     *             on failure communicating with GitHub, potentially due to an invalid ref type being requested
     */
    public GHRef[] getRefs(String refType) throws IOException {
<span class="fc" id="L1965">        return listRefs(refType).toArray();</span>
    }

    /**
     * Retrieves all refs of the given type for the current GitHub repository.
     *
     * @param refType
     *            the type of reg to search for e.g. &lt;code&gt;tags&lt;/code&gt; or &lt;code&gt;commits&lt;/code&gt;
     * @return paged iterable of all refs of the specified type
     * @throws IOException
     *             on failure communicating with GitHub, potentially due to an invalid ref type being requested
     */
    public PagedIterable&lt;GHRef&gt; listRefs(String refType) throws IOException {
<span class="fc" id="L1978">        return GHRef.readMatching(this, refType);</span>
    }

    /**
     * Retrieve a ref of the given type for the current GitHub repository.
     *
     * @param refName
     *            eg: heads/branch
     * @return refs matching the request type
     * @throws IOException
     *             on failure communicating with GitHub, potentially due to an invalid ref type being requested
     */
    public GHRef getRef(String refName) throws IOException {
<span class="fc" id="L1991">        return GHRef.read(this, refName);</span>
    }

    /**
     * Returns the &lt;strong&gt;annotated&lt;/strong&gt; tag object. Only valid if the {@link GHRef#getObject()} has a
     * {@link GHRef.GHObject#getType()} of {@code tag}.
     *
     * @param sha
     *            the sha of the tag object
     * @return the annotated tag object
     * @throws IOException
     *             the io exception
     */
    public GHTagObject getTagObject(String sha) throws IOException {
<span class="nc" id="L2005">        return root().createRequest().withUrlPath(getApiTailUrl(&quot;git/tags/&quot; + sha)).fetch(GHTagObject.class).wrap(this);</span>
    }

    /**
     * Retrieve a tree of the given type for the current GitHub repository.
     *
     * @param sha
     *            sha number or branch name ex: &quot;main&quot;
     * @return refs matching the request type
     * @throws IOException
     *             on failure communicating with GitHub, potentially due to an invalid tree type being requested
     */
    public GHTree getTree(String sha) throws IOException {
<span class="fc" id="L2018">        String url = String.format(&quot;/repos/%s/%s/git/trees/%s&quot;, getOwnerName(), name, sha);</span>
<span class="fc" id="L2019">        return root().createRequest().withUrlPath(url).fetch(GHTree.class).wrap(this);</span>
    }

    /**
     * Create tree gh tree builder.
     *
     * @return the gh tree builder
     */
    public GHTreeBuilder createTree() {
<span class="fc" id="L2028">        return new GHTreeBuilder(this);</span>
    }

    /**
     * Retrieves the tree for the current GitHub repository, recursively as described in here:
     * https://developer.github.com/v3/git/trees/#get-a-tree-recursively
     *
     * @param sha
     *            sha number or branch name ex: &quot;main&quot;
     * @param recursive
     *            use 1
     * @return the tree recursive
     * @throws IOException
     *             on failure communicating with GitHub, potentially due to an invalid tree type being requested
     */
    public GHTree getTreeRecursive(String sha, int recursive) throws IOException {
<span class="fc" id="L2044">        String url = String.format(&quot;/repos/%s/%s/git/trees/%s&quot;, getOwnerName(), name, sha);</span>
<span class="fc" id="L2045">        return root().createRequest().with(&quot;recursive&quot;, recursive).withUrlPath(url).fetch(GHTree.class).wrap(this);</span>
    }

    /**
     * Obtains the metadata &amp;amp; the content of a blob.
     *
     * &lt;p&gt;
     * This method retrieves the whole content in memory, so beware when you are dealing with large BLOB.
     *
     * @param blobSha
     *            the blob sha
     * @return the blob
     * @throws IOException
     *             the io exception
     * @see &lt;a href=&quot;https://developer.github.com/v3/git/blobs/#get-a-blob&quot;&gt;Get a blob&lt;/a&gt;
     * @see #readBlob(String) #readBlob(String)
     */
    public GHBlob getBlob(String blobSha) throws IOException {
<span class="fc" id="L2063">        String target = getApiTailUrl(&quot;git/blobs/&quot; + blobSha);</span>
<span class="fc" id="L2064">        return root().createRequest().withUrlPath(target).fetch(GHBlob.class);</span>
    }

    /**
     * Create blob gh blob builder.
     *
     * @return the gh blob builder
     */
    public GHBlobBuilder createBlob() {
<span class="fc" id="L2073">        return new GHBlobBuilder(this);</span>
    }

    /**
     * Reads the content of a blob as a stream for better efficiency.
     *
     * @param blobSha
     *            the blob sha
     * @return the input stream
     * @throws IOException
     *             the io exception
     * @see &lt;a href=&quot;https://developer.github.com/v3/git/blobs/#get-a-blob&quot;&gt;Get a blob&lt;/a&gt;
     * @see #getBlob(String) #getBlob(String)
     */
    public InputStream readBlob(String blobSha) throws IOException {
<span class="fc" id="L2088">        String target = getApiTailUrl(&quot;git/blobs/&quot; + blobSha);</span>

        // https://developer.github.com/v3/media/ describes this media type
<span class="fc" id="L2091">        return root().createRequest()</span>
<span class="fc" id="L2092">                .withHeader(&quot;Accept&quot;, &quot;application/vnd.github.raw&quot;)</span>
<span class="fc" id="L2093">                .withUrlPath(target)</span>
<span class="fc" id="L2094">                .fetchStream(Requester::copyInputStream);</span>
    }

    /**
     * Gets a commit object in this repository.
     *
     * @param sha1
     *            the sha 1
     * @return the commit
     * @throws IOException
     *             the io exception
     */
    public GHCommit getCommit(String sha1) throws IOException {
<span class="fc" id="L2107">        GHCommit c = commits.get(sha1);</span>
<span class="pc bpc" id="L2108" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="fc" id="L2109">            c = root().createRequest()</span>
<span class="fc" id="L2110">                    .withUrlPath(String.format(&quot;/repos/%s/%s/commits/%s&quot;, getOwnerName(), name, sha1))</span>
<span class="fc" id="L2111">                    .fetch(GHCommit.class)</span>
<span class="fc" id="L2112">                    .wrapUp(this);</span>
<span class="fc" id="L2113">            commits.put(sha1, c);</span>
        }
<span class="fc" id="L2115">        return c;</span>
    }

    /**
     * Create commit gh commit builder.
     *
     * @return the gh commit builder
     */
    public GHCommitBuilder createCommit() {
<span class="fc" id="L2124">        return new GHCommitBuilder(this);</span>
    }

    /**
     * Lists all the commits.
     *
     * @return the paged iterable
     */
    public PagedIterable&lt;GHCommit&gt; listCommits() {
<span class="fc" id="L2133">        return root().createRequest()</span>
<span class="fc" id="L2134">                .withUrlPath(String.format(&quot;/repos/%s/%s/commits&quot;, getOwnerName(), name))</span>
<span class="fc" id="L2135">                .toIterable(GHCommit[].class, item -&gt; item.wrapUp(this));</span>
    }

    /**
     * Search commits by specifying filters through a builder pattern.
     *
     * @return the gh commit query builder
     */
    public GHCommitQueryBuilder queryCommits() {
<span class="fc" id="L2144">        return new GHCommitQueryBuilder(this);</span>
    }

    /**
     * Lists up all the commit comments in this repository.
     *
     * @return the paged iterable
     */
    public PagedIterable&lt;GHCommitComment&gt; listCommitComments() {
<span class="fc" id="L2153">        return root().createRequest()</span>
<span class="fc" id="L2154">                .withUrlPath(String.format(&quot;/repos/%s/%s/comments&quot;, getOwnerName(), name))</span>
<span class="fc" id="L2155">                .toIterable(GHCommitComment[].class, item -&gt; item.wrap(this));</span>
    }

    /**
     * Lists all comments on a specific commit.
     *
     * @param commitSha
     *            the hash of the commit
     *
     * @return the paged iterable
     */
    public PagedIterable&lt;GHCommitComment&gt; listCommitComments(String commitSha) {
<span class="fc" id="L2167">        return root().createRequest()</span>
<span class="fc" id="L2168">                .withUrlPath(String.format(&quot;/repos/%s/%s/commits/%s/comments&quot;, getOwnerName(), name, commitSha))</span>
<span class="fc" id="L2169">                .toIterable(GHCommitComment[].class, item -&gt; item.wrap(this));</span>
    }

    /**
     * Gets the basic license details for the repository.
     *
     * @return null if there's no license.
     * @throws IOException
     *             as usual but also if you don't use the preview connector
     */
    public GHLicense getLicense() throws IOException {
<span class="fc" id="L2180">        GHContentWithLicense lic = getLicenseContent_();</span>
<span class="fc bfc" id="L2181" title="All 2 branches covered.">        return lic != null ? lic.license : null;</span>
    }

    /**
     * Retrieves the contents of the repository's license file - makes an additional API call.
     *
     * @return details regarding the license contents, or null if there's no license.
     * @throws IOException
     *             as usual but also if you don't use the preview connector
     */
    public GHContent getLicenseContent() throws IOException {
<span class="fc" id="L2192">        return getLicenseContent_();</span>
    }

    private GHContentWithLicense getLicenseContent_() throws IOException {
        try {
<span class="fc" id="L2197">            return root().createRequest()</span>
<span class="fc" id="L2198">                    .withUrlPath(getApiTailUrl(&quot;license&quot;))</span>
<span class="fc" id="L2199">                    .fetch(GHContentWithLicense.class)</span>
<span class="fc" id="L2200">                    .wrap(this);</span>
<span class="fc" id="L2201">        } catch (FileNotFoundException e) {</span>
<span class="fc" id="L2202">            return null;</span>
        }
    }

    /**
     * /** Lists all the commit statuses attached to the given commit, newer ones first.
     *
     * @param sha1
     *            the sha 1
     * @return the paged iterable
     * @throws IOException
     *             the io exception
     */
    public PagedIterable&lt;GHCommitStatus&gt; listCommitStatuses(final String sha1) throws IOException {
<span class="fc" id="L2216">        return root().createRequest()</span>
<span class="fc" id="L2217">                .withUrlPath(String.format(&quot;/repos/%s/%s/statuses/%s&quot;, getOwnerName(), name, sha1))</span>
<span class="fc" id="L2218">                .toIterable(GHCommitStatus[].class, null);</span>
    }

    /**
     * Gets the last status of this commit, which is what gets shown in the UI.
     *
     * @param sha1
     *            the sha 1
     * @return the last commit status
     * @throws IOException
     *             the io exception
     */
    public GHCommitStatus getLastCommitStatus(String sha1) throws IOException {
<span class="fc" id="L2231">        List&lt;GHCommitStatus&gt; v = listCommitStatuses(sha1).toList();</span>
<span class="pc bpc" id="L2232" title="1 of 2 branches missed.">        return v.isEmpty() ? null : v.get(0);</span>
    }

    /**
     * Gets check runs for given ref.
     *
     * @param ref
     *            ref
     * @return check runs for given ref
     * @throws IOException
     *             the io exception
     * @see &lt;a href= &quot;https://developer.github.com/v3/checks/runs/#list-check-runs-for-a-specific-ref&quot;&gt;List check runs
     *      for a specific ref&lt;/a&gt;
     */
    public PagedIterable&lt;GHCheckRun&gt; getCheckRuns(String ref) throws IOException {
<span class="fc" id="L2247">        GitHubRequest request = root().createRequest()</span>
<span class="fc" id="L2248">                .withUrlPath(String.format(&quot;/repos/%s/%s/commits/%s/check-runs&quot;, getOwnerName(), name, ref))</span>
<span class="fc" id="L2249">                .build();</span>
<span class="fc" id="L2250">        return new GHCheckRunsIterable(this, request);</span>
    }

    /**
     * Gets check runs for given ref which validate provided parameters
     *
     * @param ref
     *            the Git reference
     * @param params
     *            a map of parameters to filter check runs
     * @return check runs for the given ref
     * @throws IOException
     *             the io exception
     * @see &lt;a href= &quot;https://developer.github.com/v3/checks/runs/#list-check-runs-for-a-specific-ref&quot;&gt;List check runs
     *      for a specific ref&lt;/a&gt;
     */
    public PagedIterable&lt;GHCheckRun&gt; getCheckRuns(String ref, Map&lt;String, Object&gt; params) throws IOException {
<span class="fc" id="L2267">        GitHubRequest request = root().createRequest()</span>
<span class="fc" id="L2268">                .withUrlPath(String.format(&quot;/repos/%s/%s/commits/%s/check-runs&quot;, getOwnerName(), name, ref))</span>
<span class="fc" id="L2269">                .with(params)</span>
<span class="fc" id="L2270">                .build();</span>
<span class="fc" id="L2271">        return new GHCheckRunsIterable(this, request);</span>
    }

    /**
     * Creates a commit status.
     *
     * @param sha1
     *            the sha 1
     * @param state
     *            the state
     * @param targetUrl
     *            Optional parameter that points to the URL that has more details.
     * @param description
     *            Optional short description.
     * @param context
     *            Optional commit status context.
     * @return the gh commit status
     * @throws IOException
     *             the io exception
     */
    public GHCommitStatus createCommitStatus(String sha1,
            GHCommitState state,
            String targetUrl,
            String description,
            String context) throws IOException {
<span class="nc" id="L2296">        return root().createRequest()</span>
<span class="nc" id="L2297">                .method(&quot;POST&quot;)</span>
<span class="nc" id="L2298">                .with(&quot;state&quot;, state)</span>
<span class="nc" id="L2299">                .with(&quot;target_url&quot;, targetUrl)</span>
<span class="nc" id="L2300">                .with(&quot;description&quot;, description)</span>
<span class="nc" id="L2301">                .with(&quot;context&quot;, context)</span>
<span class="nc" id="L2302">                .withUrlPath(String.format(&quot;/repos/%s/%s/statuses/%s&quot;, getOwnerName(), this.name, sha1))</span>
<span class="nc" id="L2303">                .fetch(GHCommitStatus.class);</span>
    }

    /**
     * Create commit status gh commit status.
     *
     * @param sha1
     *            the sha 1
     * @param state
     *            the state
     * @param targetUrl
     *            the target url
     * @param description
     *            the description
     * @return the gh commit status
     * @throws IOException
     *             the io exception
     * @see #createCommitStatus(String, GHCommitState, String, String, String) #createCommitStatus(String,
     *      GHCommitState,String,String,String)
     */
    public GHCommitStatus createCommitStatus(String sha1, GHCommitState state, String targetUrl, String description)
            throws IOException {
<span class="nc" id="L2325">        return createCommitStatus(sha1, state, targetUrl, description, null);</span>
    }

    /**
     * Creates a check run for a commit.
     *
     * @param name
     *            an identifier for the run
     * @param headSHA
     *            the commit hash
     * @return a builder which you should customize, then call {@link GHCheckRunBuilder#create}
     */
    public @NonNull GHCheckRunBuilder createCheckRun(@NonNull String name, @NonNull String headSHA) {
<span class="fc" id="L2338">        return new GHCheckRunBuilder(this, name, headSHA);</span>
    }

    /**
     * Updates an existing check run.
     *
     * @param checkId
     *            the existing checkId
     * @return a builder which you should customize, then call {@link GHCheckRunBuilder#create}
     */
    public @NonNull GHCheckRunBuilder updateCheckRun(long checkId) {
<span class="nc" id="L2349">        return new GHCheckRunBuilder(this, checkId);</span>
    }

    /**
     * Lists repository events.
     *
     * @return the paged iterable
     * @throws IOException
     *             the io exception
     */
    public PagedIterable&lt;GHEventInfo&gt; listEvents() throws IOException {
<span class="nc" id="L2360">        return root().createRequest()</span>
<span class="nc" id="L2361">                .withUrlPath(String.format(&quot;/repos/%s/%s/events&quot;, getOwnerName(), name))</span>
<span class="nc" id="L2362">                .toIterable(GHEventInfo[].class, null);</span>
    }

    /**
     * Lists labels in this repository.
     * &lt;p&gt;
     * https://developer.github.com/v3/issues/labels/#list-all-labels-for-this-repository
     *
     * @return the paged iterable
     * @throws IOException
     *             the io exception
     */
    public PagedIterable&lt;GHLabel&gt; listLabels() throws IOException {
<span class="fc" id="L2375">        return GHLabel.readAll(this);</span>
    }

    /**
     * Gets label.
     *
     * @param name
     *            the name
     * @return the label
     * @throws IOException
     *             the io exception
     */
    public GHLabel getLabel(String name) throws IOException {
<span class="fc" id="L2388">        return GHLabel.read(this, name);</span>
    }

    /**
     * Create label gh label.
     *
     * @param name
     *            the name
     * @param color
     *            the color
     * @return the gh label
     * @throws IOException
     *             the io exception
     */
    public GHLabel createLabel(String name, String color) throws IOException {
<span class="fc" id="L2403">        return GHLabel.create(this).name(name).color(color).description(&quot;&quot;).done();</span>
    }

    /**
     * Description is still in preview.
     *
     * @param name
     *            the name
     * @param color
     *            the color
     * @param description
     *            the description
     * @return gh label
     * @throws IOException
     *             the io exception
     */
    public GHLabel createLabel(String name, String color, String description) throws IOException {
<span class="fc" id="L2420">        return GHLabel.create(this).name(name).color(color).description(description).done();</span>
    }

    /**
     * Lists all the invitations.
     *
     * @return the paged iterable
     */
    public PagedIterable&lt;GHInvitation&gt; listInvitations() {
<span class="nc" id="L2429">        return root().createRequest()</span>
<span class="nc" id="L2430">                .withUrlPath(String.format(&quot;/repos/%s/%s/invitations&quot;, getOwnerName(), name))</span>
<span class="nc" id="L2431">                .toIterable(GHInvitation[].class, null);</span>
    }

    /**
     * Lists all the subscribers (aka watchers.)
     * &lt;p&gt;
     * https://developer.github.com/v3/activity/watching/
     *
     * @return the paged iterable
     */
    public PagedIterable&lt;GHUser&gt; listSubscribers() {
<span class="fc" id="L2442">        return listUsers(&quot;subscribers&quot;);</span>
    }

    /**
     * Lists all the users who have starred this repo based on the old version of the API. For additional information,
     * like date when the repository was starred, see {@link #listStargazers2()}
     *
     * @return the paged iterable
     */
    public PagedIterable&lt;GHUser&gt; listStargazers() {
<span class="fc" id="L2452">        return listUsers(&quot;stargazers&quot;);</span>
    }

    /**
     * Lists all the users who have starred this repo based on new version of the API, having extended information like
     * the time when the repository was starred. For compatibility with the old API see {@link #listStargazers()}
     *
     * @return the paged iterable
     */
    public PagedIterable&lt;GHStargazer&gt; listStargazers2() {
<span class="fc" id="L2462">        return root().createRequest()</span>
<span class="fc" id="L2463">                .withAccept(&quot;application/vnd.github.star+json&quot;)</span>
<span class="fc" id="L2464">                .withUrlPath(getApiTailUrl(&quot;stargazers&quot;))</span>
<span class="fc" id="L2465">                .toIterable(GHStargazer[].class, item -&gt; item.wrapUp(this));</span>
    }

    private PagedIterable&lt;GHUser&gt; listUsers(final String suffix) {
<span class="fc" id="L2469">        return listUsers(root().createRequest(), suffix);</span>
    }

    private PagedIterable&lt;GHUser&gt; listUsers(Requester requester, final String suffix) {
<span class="fc" id="L2473">        return requester.withUrlPath(getApiTailUrl(suffix)).toIterable(GHUser[].class, null);</span>
    }

    /**
     * See https://api.github.com/hooks for possible names and their configuration scheme. TODO: produce type-safe
     * binding
     *
     * @param name
     *            Type of the hook to be created. See https://api.github.com/hooks for possible names.
     * @param config
     *            The configuration hash.
     * @param events
     *            Can be null. Types of events to hook into.
     * @param active
     *            the active
     * @return the gh hook
     * @throws IOException
     *             the io exception
     */
    public GHHook createHook(String name, Map&lt;String, String&gt; config, Collection&lt;GHEvent&gt; events, boolean active)
            throws IOException {
<span class="fc" id="L2494">        return GHHooks.repoContext(this, owner).createHook(name, config, events, active);</span>
    }

    /**
     * Create web hook gh hook.
     *
     * @param url
     *            the url
     * @param events
     *            the events
     * @return the gh hook
     * @throws IOException
     *             the io exception
     */
    public GHHook createWebHook(URL url, Collection&lt;GHEvent&gt; events) throws IOException {
<span class="fc" id="L2509">        return createHook(&quot;web&quot;, Collections.singletonMap(&quot;url&quot;, url.toExternalForm()), events, true);</span>
    }

    /**
     * Create web hook gh hook.
     *
     * @param url
     *            the url
     * @return the gh hook
     * @throws IOException
     *             the io exception
     */
    public GHHook createWebHook(URL url) throws IOException {
<span class="fc" id="L2522">        return createWebHook(url, null);</span>
    }

    /**
     * Returns a set that represents the post-commit hook URLs. The returned set is live, and changes made to them are
     * reflected to GitHub.
     *
     * @return the post commit hooks
     * @deprecated Use {@link #getHooks()} and {@link #createHook(String, Map, Collection, boolean)}
     */
    @SuppressFBWarnings(value = { &quot;DMI_COLLECTION_OF_URLS&quot;, &quot;EI_EXPOSE_REP&quot; },
            justification = &quot;It causes a performance degradation, but we have already exposed it to the API&quot;)
    @Deprecated
    public Set&lt;URL&gt; getPostCommitHooks() {
<span class="fc" id="L2536">        synchronized (this) {</span>
<span class="pc bpc" id="L2537" title="1 of 2 branches missed.">            if (postCommitHooks == null) {</span>
<span class="fc" id="L2538">                postCommitHooks = setupPostCommitHooks();</span>
            }
<span class="fc" id="L2540">            return postCommitHooks;</span>
        }
    }

    /**
     * Live set view of the post-commit hook.
     */
    @SuppressFBWarnings(value = &quot;DMI_COLLECTION_OF_URLS&quot;,
            justification = &quot;It causes a performance degradation, but we have already exposed it to the API&quot;)
    @SkipFromToString
    private /* final */ transient Set&lt;URL&gt; postCommitHooks;

    @SuppressFBWarnings(value = &quot;DMI_COLLECTION_OF_URLS&quot;,
            justification = &quot;It causes a performance degradation, but we have already exposed it to the API&quot;)
    private Set&lt;URL&gt; setupPostCommitHooks() {
<span class="fc" id="L2555">        return new AbstractSet&lt;URL&gt;() {</span>
            private List&lt;URL&gt; getPostCommitHooks() {
                try {
<span class="fc" id="L2558">                    List&lt;URL&gt; r = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L2559" title="1 of 2 branches missed.">                    for (GHHook h : getHooks()) {</span>
<span class="nc bnc" id="L2560" title="All 2 branches missed.">                        if (h.getName().equals(&quot;web&quot;)) {</span>
<span class="nc" id="L2561">                            r.add(new URL(h.getConfig().get(&quot;url&quot;)));</span>
                        }
<span class="nc" id="L2563">                    }</span>
<span class="fc" id="L2564">                    return r;</span>
<span class="nc" id="L2565">                } catch (IOException e) {</span>
<span class="nc" id="L2566">                    throw new GHException(&quot;Failed to retrieve post-commit hooks&quot;, e);</span>
                }
            }

            @Override
            public Iterator&lt;URL&gt; iterator() {
<span class="nc" id="L2572">                return getPostCommitHooks().iterator();</span>
            }

            @Override
            public int size() {
<span class="fc" id="L2577">                return getPostCommitHooks().size();</span>
            }

            @Override
            public boolean add(URL url) {
                try {
<span class="nc" id="L2583">                    createWebHook(url);</span>
<span class="nc" id="L2584">                    return true;</span>
<span class="nc" id="L2585">                } catch (IOException e) {</span>
<span class="nc" id="L2586">                    throw new GHException(&quot;Failed to update post-commit hooks&quot;, e);</span>
                }
            }

            @Override
            public boolean remove(Object url) {
                try {
<span class="nc" id="L2593">                    String _url = ((URL) url).toExternalForm();</span>
<span class="nc bnc" id="L2594" title="All 2 branches missed.">                    for (GHHook h : getHooks()) {</span>
<span class="nc bnc" id="L2595" title="All 4 branches missed.">                        if (h.getName().equals(&quot;web&quot;) &amp;&amp; h.getConfig().get(&quot;url&quot;).equals(_url)) {</span>
<span class="nc" id="L2596">                            h.delete();</span>
<span class="nc" id="L2597">                            return true;</span>
                        }
<span class="nc" id="L2599">                    }</span>
<span class="nc" id="L2600">                    return false;</span>
<span class="nc" id="L2601">                } catch (IOException e) {</span>
<span class="nc" id="L2602">                    throw new GHException(&quot;Failed to update post-commit hooks&quot;, e);</span>
                }
            }
        };
    }

    /**
     * Gets branches by {@linkplain GHBranch#getName() their names}.
     *
     * @return the branches
     * @throws IOException
     *             the io exception
     */
    public Map&lt;String, GHBranch&gt; getBranches() throws IOException {
<span class="fc" id="L2616">        Map&lt;String, GHBranch&gt; r = new TreeMap&lt;String, GHBranch&gt;();</span>
<span class="fc" id="L2617">        for (GHBranch p : root().createRequest()</span>
<span class="fc" id="L2618">                .withUrlPath(getApiTailUrl(&quot;branches&quot;))</span>
<span class="fc" id="L2619">                .toIterable(GHBranch[].class, item -&gt; item.wrap(this))</span>
<span class="fc bfc" id="L2620" title="All 2 branches covered.">                .toArray()) {</span>
<span class="fc" id="L2621">            r.put(p.getName(), p);</span>
        }
<span class="fc" id="L2623">        return r;</span>
    }

    /**
     * Gets branch.
     *
     * @param name
     *            the name
     * @return the branch
     * @throws IOException
     *             the io exception
     */
    public GHBranch getBranch(String name) throws IOException {
<span class="fc" id="L2636">        return root().createRequest().withUrlPath(getApiTailUrl(&quot;branches/&quot; + name)).fetch(GHBranch.class).wrap(this);</span>
    }

    /**
     * Gets milestones.
     *
     * @return the milestones
     * @throws IOException
     *             the io exception
     * @deprecated Use {@link #listMilestones(GHIssueState)}
     */
    public Map&lt;Integer, GHMilestone&gt; getMilestones() throws IOException {
<span class="nc" id="L2648">        Map&lt;Integer, GHMilestone&gt; milestones = new TreeMap&lt;Integer, GHMilestone&gt;();</span>
<span class="nc bnc" id="L2649" title="All 2 branches missed.">        for (GHMilestone m : listMilestones(GHIssueState.OPEN)) {</span>
<span class="nc" id="L2650">            milestones.put(m.getNumber(), m);</span>
<span class="nc" id="L2651">        }</span>
<span class="nc" id="L2652">        return milestones;</span>
    }

    /**
     * Lists up all the milestones in this repository.
     *
     * @param state
     *            the state
     * @return the paged iterable
     */
    public PagedIterable&lt;GHMilestone&gt; listMilestones(final GHIssueState state) {
<span class="nc" id="L2663">        return root().createRequest()</span>
<span class="nc" id="L2664">                .with(&quot;state&quot;, state)</span>
<span class="nc" id="L2665">                .withUrlPath(getApiTailUrl(&quot;milestones&quot;))</span>
<span class="nc" id="L2666">                .toIterable(GHMilestone[].class, item -&gt; item.lateBind(this));</span>
    }

    /**
     * Gets milestone.
     *
     * @param number
     *            the number
     * @return the milestone
     * @throws IOException
     *             the io exception
     */
    public GHMilestone getMilestone(int number) throws IOException {
<span class="fc" id="L2679">        GHMilestone m = milestones.get(number);</span>
<span class="pc bpc" id="L2680" title="1 of 2 branches missed.">        if (m == null) {</span>
<span class="fc" id="L2681">            m = root().createRequest().withUrlPath(getApiTailUrl(&quot;milestones/&quot; + number)).fetch(GHMilestone.class);</span>
<span class="fc" id="L2682">            m.owner = this;</span>
<span class="fc" id="L2683">            milestones.put(m.getNumber(), m);</span>
        }
<span class="fc" id="L2685">        return m;</span>
    }

    /**
     * Gets file content.
     *
     * @param path
     *            the path
     * @return the file content
     * @throws IOException
     *             the io exception
     */
    public GHContent getFileContent(String path) throws IOException {
<span class="fc" id="L2698">        return getFileContent(path, null);</span>
    }

    /**
     * Gets file content.
     *
     * @param path
     *            the path
     * @param ref
     *            the ref
     * @return the file content
     * @throws IOException
     *             the io exception
     */
    public GHContent getFileContent(String path, String ref) throws IOException {
<span class="fc" id="L2713">        Requester requester = root().createRequest();</span>
<span class="fc" id="L2714">        String target = getApiTailUrl(&quot;contents/&quot; + path);</span>

<span class="fc" id="L2716">        return requester.with(&quot;ref&quot;, ref).withUrlPath(target).fetch(GHContent.class).wrap(this);</span>
    }

    /**
     * Gets directory content.
     *
     * @param path
     *            the path
     * @return the directory content
     * @throws IOException
     *             the io exception
     */
    public List&lt;GHContent&gt; getDirectoryContent(String path) throws IOException {
<span class="fc" id="L2729">        return getDirectoryContent(path, null);</span>
    }

    /**
     * Gets directory content.
     *
     * @param path
     *            the path
     * @param ref
     *            the ref
     * @return the directory content
     * @throws IOException
     *             the io exception
     */
    public List&lt;GHContent&gt; getDirectoryContent(String path, String ref) throws IOException {
<span class="fc" id="L2744">        Requester requester = root().createRequest();</span>
<span class="fc bfc" id="L2745" title="All 2 branches covered.">        while (path.endsWith(&quot;/&quot;)) {</span>
<span class="fc" id="L2746">            path = path.substring(0, path.length() - 1);</span>
        }
<span class="fc" id="L2748">        String target = getApiTailUrl(&quot;contents/&quot; + path);</span>

<span class="fc" id="L2750">        return requester.with(&quot;ref&quot;, ref)</span>
<span class="fc" id="L2751">                .withUrlPath(target)</span>
<span class="fc" id="L2752">                .toIterable(GHContent[].class, item -&gt; item.wrap(this))</span>
<span class="fc" id="L2753">                .toList();</span>
    }

    /**
     * https://developer.github.com/v3/repos/contents/#get-the-readme
     *
     * @return the readme
     * @throws IOException
     *             the io exception
     */
    public GHContent getReadme() throws IOException {
<span class="fc" id="L2764">        Requester requester = root().createRequest();</span>
<span class="fc" id="L2765">        return requester.withUrlPath(getApiTailUrl(&quot;readme&quot;)).fetch(GHContent.class).wrap(this);</span>
    }

    /**
     * Create a repository variable.
     *
     * @param name
     *            the variable name (e.g. test-variable)
     * @param value
     *            the value
     * @throws IOException
     *             the io exception
     */
    public void createVariable(String name, String value) throws IOException {
<span class="fc" id="L2779">        GHRepositoryVariable.create(this).name(name).value(value).done();</span>
<span class="fc" id="L2780">    }</span>

    /**
     * Gets a variable by name
     *
     * @param name
     *            the variable name (e.g. test-variable)
     * @return the variable
     * @throws IOException
     *             the io exception
     */
    @Deprecated
    public GHRepositoryVariable getRepoVariable(String name) throws IOException {
<span class="fc" id="L2793">        return getVariable(name);</span>
    }

    /**
     * Gets a repository variable.
     *
     * @param name
     *            the variable name (e.g. test-variable)
     * @return the variable
     * @throws IOException
     *             the io exception
     */
    public GHRepositoryVariable getVariable(String name) throws IOException {
<span class="fc" id="L2806">        return GHRepositoryVariable.read(this, name);</span>
    }

    /**
     * Creates a new content, or update an existing content.
     *
     * @return the gh content builder
     */
    public GHContentBuilder createContent() {
<span class="fc" id="L2815">        return new GHContentBuilder(this);</span>
    }

    /**
     * Use {@link #createContent()}.
     *
     * @param content
     *            the content
     * @param commitMessage
     *            the commit message
     * @param path
     *            the path
     * @return the gh content update response
     * @throws IOException
     *             the io exception
     */
    @Deprecated
    public GHContentUpdateResponse createContent(String content, String commitMessage, String path) throws IOException {
<span class="fc" id="L2833">        return createContent().content(content).message(commitMessage).path(path).commit();</span>
    }

    /**
     * Use {@link #createContent()}.
     *
     * @param content
     *            the content
     * @param commitMessage
     *            the commit message
     * @param path
     *            the path
     * @param branch
     *            the branch
     * @return the gh content update response
     * @throws IOException
     *             the io exception
     */
    @Deprecated
    public GHContentUpdateResponse createContent(String content, String commitMessage, String path, String branch)
            throws IOException {
<span class="fc" id="L2854">        return createContent().content(content).message(commitMessage).path(path).branch(branch).commit();</span>
    }

    /**
     * Use {@link #createContent()}.
     *
     * @param contentBytes
     *            the content bytes
     * @param commitMessage
     *            the commit message
     * @param path
     *            the path
     * @return the gh content update response
     * @throws IOException
     *             the io exception
     */
    @Deprecated
    public GHContentUpdateResponse createContent(byte[] contentBytes, String commitMessage, String path)
            throws IOException {
<span class="nc" id="L2873">        return createContent().content(contentBytes).message(commitMessage).path(path).commit();</span>
    }

    /**
     * Use {@link #createContent()}.
     *
     * @param contentBytes
     *            the content bytes
     * @param commitMessage
     *            the commit message
     * @param path
     *            the path
     * @param branch
     *            the branch
     * @return the gh content update response
     * @throws IOException
     *             the io exception
     */
    @Deprecated
    public GHContentUpdateResponse createContent(byte[] contentBytes, String commitMessage, String path, String branch)
            throws IOException {
<span class="nc" id="L2894">        return createContent().content(contentBytes).message(commitMessage).path(path).branch(branch).commit();</span>
    }

    /**
     * Create milestone gh milestone.
     *
     * @param title
     *            the title
     * @param description
     *            the description
     * @return the gh milestone
     * @throws IOException
     *             the io exception
     */
    public GHMilestone createMilestone(String title, String description) throws IOException {
<span class="fc" id="L2909">        return root().createRequest()</span>
<span class="fc" id="L2910">                .method(&quot;POST&quot;)</span>
<span class="fc" id="L2911">                .with(&quot;title&quot;, title)</span>
<span class="fc" id="L2912">                .with(&quot;description&quot;, description)</span>
<span class="fc" id="L2913">                .withUrlPath(getApiTailUrl(&quot;milestones&quot;))</span>
<span class="fc" id="L2914">                .fetch(GHMilestone.class)</span>
<span class="fc" id="L2915">                .lateBind(this);</span>
    }

    /**
     * Add deploy key gh deploy key.
     *
     * @param title
     *            the title
     * @param key
     *            the key
     * @return the gh deploy key
     * @throws IOException
     *             the io exception
     */
    public GHDeployKey addDeployKey(String title, String key) throws IOException {
<span class="fc" id="L2930">        return addDeployKey(title, key, false);</span>
    }

    /**
     * Add deploy key gh deploy key.
     *
     * @param title
     *            the title
     * @param key
     *            the key
     * @param readOnly
     *            read-only ability of the key
     * @return the gh deploy key
     * @throws IOException
     *             the io exception
     */
    public GHDeployKey addDeployKey(String title, String key, boolean readOnly) throws IOException {
<span class="fc" id="L2947">        return root().createRequest()</span>
<span class="fc" id="L2948">                .method(&quot;POST&quot;)</span>
<span class="fc" id="L2949">                .with(&quot;title&quot;, title)</span>
<span class="fc" id="L2950">                .with(&quot;key&quot;, key)</span>
<span class="fc" id="L2951">                .with(&quot;read_only&quot;, readOnly)</span>
<span class="fc" id="L2952">                .withUrlPath(getApiTailUrl(&quot;keys&quot;))</span>
<span class="fc" id="L2953">                .fetch(GHDeployKey.class)</span>
<span class="fc" id="L2954">                .lateBind(this);</span>
    }

    /**
     * Gets deploy keys.
     *
     * @return the deploy keys
     * @throws IOException
     *             the io exception
     */
    public List&lt;GHDeployKey&gt; getDeployKeys() throws IOException {
<span class="fc" id="L2965">        return root().createRequest()</span>
<span class="fc" id="L2966">                .withUrlPath(getApiTailUrl(&quot;keys&quot;))</span>
<span class="fc" id="L2967">                .toIterable(GHDeployKey[].class, item -&gt; item.lateBind(this))</span>
<span class="fc" id="L2968">                .toList();</span>
    }

    /**
     * Forked repositories have a 'source' attribute that specifies the ultimate source of the forking chain.
     *
     * @return {@link GHRepository} that points to the root repository where this repository is forked (indirectly or
     *         directly) from. Otherwise null.
     * @throws IOException
     *             the io exception
     * @see #getParent() #getParent()
     */
    @SuppressFBWarnings(value = { &quot;EI_EXPOSE_REP&quot; }, justification = &quot;Expected behavior&quot;)
    public GHRepository getSource() throws IOException {
<span class="pc bpc" id="L2982" title="1 of 4 branches missed.">        if (fork &amp;&amp; source == null) {</span>
<span class="fc" id="L2983">            populate();</span>
        }
<span class="fc bfc" id="L2985" title="All 2 branches covered.">        if (source == null) {</span>
<span class="fc" id="L2986">            return null;</span>
        }

<span class="fc" id="L2989">        return source;</span>
    }

    /**
     * Forked repositories have a 'parent' attribute that specifies the repository this repository is directly forked
     * from. If we keep traversing {@link #getParent()} until it returns null, that is {@link #getSource()}.
     *
     * @return {@link GHRepository} that points to the repository where this repository is forked directly from.
     *         Otherwise null.
     * @throws IOException
     *             the io exception
     * @see #getSource() #getSource()
     */
    @SuppressFBWarnings(value = { &quot;EI_EXPOSE_REP&quot; }, justification = &quot;Expected behavior&quot;)
    public GHRepository getParent() throws IOException {
<span class="pc bpc" id="L3004" title="1 of 4 branches missed.">        if (fork &amp;&amp; parent == null) {</span>
<span class="fc" id="L3005">            populate();</span>
        }

<span class="fc bfc" id="L3008" title="All 2 branches covered.">        if (parent == null) {</span>
<span class="fc" id="L3009">            return null;</span>
        }
<span class="fc" id="L3011">        return parent;</span>
    }

    /**
     * Subscribes to this repository to get notifications.
     *
     * @param subscribed
     *            the subscribed
     * @param ignored
     *            the ignored
     * @return the gh subscription
     * @throws IOException
     *             the io exception
     */
    public GHSubscription subscribe(boolean subscribed, boolean ignored) throws IOException {
<span class="fc" id="L3026">        return root().createRequest()</span>
<span class="fc" id="L3027">                .method(&quot;PUT&quot;)</span>
<span class="fc" id="L3028">                .with(&quot;subscribed&quot;, subscribed)</span>
<span class="fc" id="L3029">                .with(&quot;ignored&quot;, ignored)</span>
<span class="fc" id="L3030">                .withUrlPath(getApiTailUrl(&quot;subscription&quot;))</span>
<span class="fc" id="L3031">                .fetch(GHSubscription.class)</span>
<span class="fc" id="L3032">                .wrapUp(this);</span>
    }

    /**
     * Returns the current subscription.
     *
     * @return null if no subscription exists.
     * @throws IOException
     *             the io exception
     */
    public GHSubscription getSubscription() throws IOException {
        try {
<span class="pc" id="L3044">            return root().createRequest()</span>
<span class="fc" id="L3045">                    .withUrlPath(getApiTailUrl(&quot;subscription&quot;))</span>
<span class="nc" id="L3046">                    .fetch(GHSubscription.class)</span>
<span class="nc" id="L3047">                    .wrapUp(this);</span>
<span class="fc" id="L3048">        } catch (FileNotFoundException e) {</span>
<span class="fc" id="L3049">            return null;</span>
        }
    }

    // Only used within listCodeownersErrors().
    private static class GHCodeownersErrors {
        public List&lt;GHCodeownersError&gt; errors;
    }

    /**
     * List errors in the {@code CODEOWNERS} file. Note that GitHub skips lines with incorrect syntax; these are
     * reported in the web interface, but not in the API call which this library uses.
     *
     * @return the list of errors
     * @throws IOException
     *             the io exception
     */
    public List&lt;GHCodeownersError&gt; listCodeownersErrors() throws IOException {
<span class="fc" id="L3067">        return root().createRequest()</span>
<span class="fc" id="L3068">                .withUrlPath(getApiTailUrl(&quot;codeowners/errors&quot;))</span>
<span class="fc" id="L3069">                .fetch(GHCodeownersErrors.class).errors;</span>
    }

    /**
     * List contributors paged iterable.
     *
     * @return the paged iterable
     * @throws IOException
     *             the io exception
     */
    public PagedIterable&lt;Contributor&gt; listContributors() throws IOException {
<span class="fc" id="L3080">        return root().createRequest().withUrlPath(getApiTailUrl(&quot;contributors&quot;)).toIterable(Contributor[].class, null);</span>
    }

    /**
     * The type Contributor.
     */
<span class="fc" id="L3086">    public static class Contributor extends GHUser {</span>
        private int contributions;

        /**
         * Gets contributions.
         *
         * @return the contributions
         */
        public int getContributions() {
<span class="fc" id="L3095">            return contributions;</span>
        }

        /**
         * Hash code.
         *
         * @return the int
         */
        @Override
        public int hashCode() {
            // We ignore contributions in the calculation
<span class="nc" id="L3106">            return super.hashCode();</span>
        }

        /**
         * Equals.
         *
         * @param obj
         *            the obj
         * @return true, if successful
         */
        @Override
        public boolean equals(Object obj) {
            // We ignore contributions in the calculation
<span class="nc" id="L3119">            return super.equals(obj);</span>
        }
    }

    /**
     * Returns the statistics for this repository.
     *
     * @return the statistics
     */
    public GHRepositoryStatistics getStatistics() {
        // TODO: Use static object and introduce refresh() method,
        // instead of returning new object each time.
<span class="fc" id="L3131">        return new GHRepositoryStatistics(this);</span>
    }

    /**
     * Create a project for this repository.
     *
     * @param name
     *            the name
     * @param body
     *            the body
     * @return the gh project
     * @throws IOException
     *             the io exception
     */
    public GHProject createProject(String name, String body) throws IOException {
<span class="nc" id="L3146">        return root().createRequest()</span>
<span class="nc" id="L3147">                .method(&quot;POST&quot;)</span>
<span class="nc" id="L3148">                .with(&quot;name&quot;, name)</span>
<span class="nc" id="L3149">                .with(&quot;body&quot;, body)</span>
<span class="nc" id="L3150">                .withUrlPath(getApiTailUrl(&quot;projects&quot;))</span>
<span class="nc" id="L3151">                .fetch(GHProject.class)</span>
<span class="nc" id="L3152">                .lateBind(this);</span>
    }

    /**
     * Returns the projects for this repository.
     *
     * @param status
     *            The status filter (all, open or closed).
     * @return the paged iterable
     * @throws IOException
     *             the io exception
     */
    public PagedIterable&lt;GHProject&gt; listProjects(final GHProject.ProjectStateFilter status) throws IOException {
<span class="nc" id="L3165">        return root().createRequest()</span>
<span class="nc" id="L3166">                .with(&quot;state&quot;, status)</span>
<span class="nc" id="L3167">                .withUrlPath(getApiTailUrl(&quot;projects&quot;))</span>
<span class="nc" id="L3168">                .toIterable(GHProject[].class, item -&gt; item.lateBind(this));</span>
    }

    /**
     * Returns open projects for this repository.
     *
     * @return the paged iterable
     * @throws IOException
     *             the io exception
     */
    public PagedIterable&lt;GHProject&gt; listProjects() throws IOException {
<span class="nc" id="L3179">        return listProjects(GHProject.ProjectStateFilter.OPEN);</span>
    }

    /**
     * Render a Markdown document.
     * &lt;p&gt;
     * In {@linkplain MarkdownMode#GFM GFM mode}, issue numbers and user mentions are linked accordingly.
     *
     * @param text
     *            the text
     * @param mode
     *            the mode
     * @return the reader
     * @throws IOException
     *             the io exception
     * @see GitHub#renderMarkdown(String) GitHub#renderMarkdown(String)
     */
    public Reader renderMarkdown(String text, MarkdownMode mode) throws IOException {
<span class="fc" id="L3197">        return new InputStreamReader(</span>
<span class="fc" id="L3198">                root().createRequest()</span>
<span class="fc" id="L3199">                        .method(&quot;POST&quot;)</span>
<span class="fc" id="L3200">                        .with(&quot;text&quot;, text)</span>
<span class="pc bpc" id="L3201" title="1 of 2 branches missed.">                        .with(&quot;mode&quot;, mode == null ? null : mode.toString())</span>
<span class="fc" id="L3202">                        .with(&quot;context&quot;, getFullName())</span>
<span class="fc" id="L3203">                        .withUrlPath(&quot;/markdown&quot;)</span>
<span class="fc" id="L3204">                        .fetchStream(Requester::copyInputStream),</span>
                &quot;UTF-8&quot;);
    }

    /**
     * List all the notifications in a repository for the current user.
     *
     * @return the gh notification stream
     */
    public GHNotificationStream listNotifications() {
<span class="nc" id="L3214">        return new GHNotificationStream(root(), getApiTailUrl(&quot;/notifications&quot;));</span>
    }

    /**
     * &lt;a href=
     * &quot;https://developer.github.com/v3/repos/traffic/#views&quot;&gt;https://developer.github.com/v3/repos/traffic/#views&lt;/a&gt;
     *
     * @return the view traffic
     * @throws IOException
     *             the io exception
     */
    public GHRepositoryViewTraffic getViewTraffic() throws IOException {
<span class="fc" id="L3226">        return root().createRequest().withUrlPath(getApiTailUrl(&quot;/traffic/views&quot;)).fetch(GHRepositoryViewTraffic.class);</span>
    }

    /**
     * &lt;a href=
     * &quot;https://developer.github.com/v3/repos/traffic/#clones&quot;&gt;https://developer.github.com/v3/repos/traffic/#clones&lt;/a&gt;
     *
     * @return the clone traffic
     * @throws IOException
     *             the io exception
     */
    public GHRepositoryCloneTraffic getCloneTraffic() throws IOException {
<span class="fc" id="L3238">        return root().createRequest()</span>
<span class="fc" id="L3239">                .withUrlPath(getApiTailUrl(&quot;/traffic/clones&quot;))</span>
<span class="fc" id="L3240">                .fetch(GHRepositoryCloneTraffic.class);</span>
    }

    /**
     * Hash code.
     *
     * @return the int
     */
    @Override
    public int hashCode() {
<span class="nc" id="L3250">        return (&quot;Repository:&quot; + getOwnerName() + &quot;:&quot; + name).hashCode();</span>
    }

    /**
     * Equals.
     *
     * @param obj
     *            the obj
     * @return true, if successful
     */
    @Override
    public boolean equals(Object obj) {
<span class="pc bpc" id="L3262" title="1 of 2 branches missed.">        if (obj instanceof GHRepository) {</span>
<span class="fc" id="L3263">            GHRepository that = (GHRepository) obj;</span>
<span class="pc bpc" id="L3264" title="1 of 4 branches missed.">            return this.getOwnerName().equals(that.getOwnerName()) &amp;&amp; this.name.equals(that.name);</span>
        }
<span class="nc" id="L3266">        return false;</span>
    }

    /**
     * Gets the api tail url.
     *
     * @param tail
     *            the tail
     * @return the api tail url
     */
    String getApiTailUrl(String tail) {
<span class="fc bfc" id="L3277" title="All 4 branches covered.">        if (tail.length() &gt; 0 &amp;&amp; !tail.startsWith(&quot;/&quot;)) {</span>
<span class="fc" id="L3278">            tail = '/' + tail;</span>
        }
<span class="fc" id="L3280">        return &quot;/repos/&quot; + full_name + tail;</span>
    }

    /**
     * Get all issue events for this repository. See
     * https://developer.github.com/v3/issues/events/#list-events-for-a-repository
     *
     * @return the paged iterable
     * @throws IOException
     *             the io exception
     */
    public PagedIterable&lt;GHIssueEvent&gt; listIssueEvents() throws IOException {
<span class="fc" id="L3292">        return root().createRequest()</span>
<span class="fc" id="L3293">                .withUrlPath(getApiTailUrl(&quot;issues/events&quot;))</span>
<span class="fc" id="L3294">                .toIterable(GHIssueEvent[].class, null);</span>
    }

    /**
     * Get a single issue event. See https://developer.github.com/v3/issues/events/#get-a-single-event
     *
     * @param id
     *            the id
     * @return the issue event
     * @throws IOException
     *             the io exception
     */
    public GHIssueEvent getIssueEvent(long id) throws IOException {
<span class="fc" id="L3307">        return root().createRequest().withUrlPath(getApiTailUrl(&quot;issues/events/&quot; + id)).fetch(GHIssueEvent.class);</span>
    }

    /**
     * Lists all the workflows of this repository.
     *
     * @return the paged iterable
     */
    public PagedIterable&lt;GHWorkflow&gt; listWorkflows() {
<span class="fc" id="L3316">        return new GHWorkflowsIterable(this);</span>
    }

    /**
     * Gets a workflow by id.
     *
     * @param id
     *            the id of the workflow run
     * @return the workflow run
     * @throws IOException
     *             the io exception
     */
    public GHWorkflow getWorkflow(long id) throws IOException {
<span class="fc" id="L3329">        return getWorkflow(String.valueOf(id));</span>
    }

    /**
     * Gets a workflow by name of the file.
     *
     * @param nameOrId
     *            either the name of the file (e.g. my-workflow.yml) or the id as a string
     * @return the workflow run
     * @throws IOException
     *             the io exception
     */
    public GHWorkflow getWorkflow(String nameOrId) throws IOException {
<span class="fc" id="L3342">        return root().createRequest()</span>
<span class="fc" id="L3343">                .withUrlPath(getApiTailUrl(&quot;actions/workflows&quot;), nameOrId)</span>
<span class="fc" id="L3344">                .fetch(GHWorkflow.class)</span>
<span class="fc" id="L3345">                .wrapUp(this);</span>
    }

    /**
     * Retrieves workflow runs.
     *
     * @return the workflow run query builder
     */
    public GHWorkflowRunQueryBuilder queryWorkflowRuns() {
<span class="fc" id="L3354">        return new GHWorkflowRunQueryBuilder(this);</span>
    }

    /**
     * Gets a workflow run.
     *
     * @param id
     *            the id of the workflow run
     * @return the workflow run
     * @throws IOException
     *             the io exception
     */
    public GHWorkflowRun getWorkflowRun(long id) throws IOException {
<span class="fc" id="L3367">        return root().createRequest()</span>
<span class="fc" id="L3368">                .withUrlPath(getApiTailUrl(&quot;actions/runs&quot;), String.valueOf(id))</span>
<span class="fc" id="L3369">                .fetch(GHWorkflowRun.class)</span>
<span class="fc" id="L3370">                .wrapUp(this);</span>
    }

    /**
     * Lists all the artifacts of this repository.
     *
     * @return the paged iterable
     */
    public PagedIterable&lt;GHArtifact&gt; listArtifacts() {
<span class="fc" id="L3379">        return new GHArtifactsIterable(this, root().createRequest().withUrlPath(getApiTailUrl(&quot;actions/artifacts&quot;)));</span>
    }

    /**
     * Gets an artifact by id.
     *
     * @param id
     *            the id of the artifact
     * @return the artifact
     * @throws IOException
     *             the io exception
     */
    public GHArtifact getArtifact(long id) throws IOException {
<span class="fc" id="L3392">        return root().createRequest()</span>
<span class="fc" id="L3393">                .withUrlPath(getApiTailUrl(&quot;actions/artifacts&quot;), String.valueOf(id))</span>
<span class="fc" id="L3394">                .fetch(GHArtifact.class)</span>
<span class="fc" id="L3395">                .wrapUp(this);</span>
    }

    /**
     * Gets a job from a workflow run by id.
     *
     * @param id
     *            the id of the job
     * @return the job
     * @throws IOException
     *             the io exception
     */
    public GHWorkflowJob getWorkflowJob(long id) throws IOException {
<span class="fc" id="L3408">        return root().createRequest()</span>
<span class="fc" id="L3409">                .withUrlPath(getApiTailUrl(&quot;/actions/jobs&quot;), String.valueOf(id))</span>
<span class="fc" id="L3410">                .fetch(GHWorkflowJob.class)</span>
<span class="fc" id="L3411">                .wrapUp(this);</span>
    }

    /**
     * Gets the public key for the given repo.
     *
     * @return the public key
     * @throws IOException
     *             the io exception
     */
    public GHRepositoryPublicKey getPublicKey() throws IOException {
<span class="fc" id="L3422">        return root().createRequest()</span>
<span class="fc" id="L3423">                .withUrlPath(getApiTailUrl(&quot;/actions/secrets/public-key&quot;))</span>
<span class="fc" id="L3424">                .fetch(GHRepositoryPublicKey.class)</span>
<span class="fc" id="L3425">                .wrapUp(this);</span>
    }

    // Only used within listTopics().
    private static class Topics {
        public List&lt;String&gt; names;
    }

    /**
     * Return the topics for this repository. See
     * https://developer.github.com/v3/repos/#list-all-topics-for-a-repository
     *
     * @return the list
     * @throws IOException
     *             the io exception
     */
    public List&lt;String&gt; listTopics() throws IOException {
<span class="fc" id="L3442">        Topics topics = root().createRequest().withUrlPath(getApiTailUrl(&quot;topics&quot;)).fetch(Topics.class);</span>
<span class="fc" id="L3443">        return topics.names;</span>
    }

    /**
     * Set the topics for this repository. See
     * https://developer.github.com/v3/repos/#replace-all-topics-for-a-repository
     *
     * @param topics
     *            the topics
     * @throws IOException
     *             the io exception
     */
    public void setTopics(List&lt;String&gt; topics) throws IOException {
<span class="fc" id="L3456">        root().createRequest().method(&quot;PUT&quot;).with(&quot;names&quot;, topics).withUrlPath(getApiTailUrl(&quot;topics&quot;)).send();</span>
<span class="fc" id="L3457">    }</span>

    /**
     * Set/Update a repository secret
     * &quot;https://docs.github.com/rest/reference/actions#create-or-update-a-repository-secret&quot;
     *
     * @param secretName
     *            the name of the secret
     * @param encryptedValue
     *            The encrypted value for this secret
     * @param publicKeyId
     *            The id of the Public Key used to encrypt this secret
     * @throws IOException
     *             the io exception
     */
    public void createSecret(String secretName, String encryptedValue, String publicKeyId) throws IOException {
<span class="fc" id="L3473">        root().createRequest()</span>
<span class="fc" id="L3474">                .method(&quot;PUT&quot;)</span>
<span class="fc" id="L3475">                .with(&quot;encrypted_value&quot;, encryptedValue)</span>
<span class="fc" id="L3476">                .with(&quot;key_id&quot;, publicKeyId)</span>
<span class="fc" id="L3477">                .withUrlPath(getApiTailUrl(&quot;actions/secrets&quot;) + &quot;/&quot; + secretName)</span>
<span class="fc" id="L3478">                .send();</span>
<span class="fc" id="L3479">    }</span>

    /**
     * Create a tag. See https://developer.github.com/v3/git/tags/#create-a-tag-object
     *
     * @param tag
     *            The tag's name.
     * @param message
     *            The tag message.
     * @param object
     *            The SHA of the git object this is tagging.
     * @param type
     *            The type of the object we're tagging: &quot;commit&quot;, &quot;tree&quot; or &quot;blob&quot;.
     * @return The newly created tag.
     * @throws IOException
     *             Signals that an I/O exception has occurred.
     */
    public GHTagObject createTag(String tag, String message, String object, String type) throws IOException {
<span class="fc" id="L3497">        return root().createRequest()</span>
<span class="fc" id="L3498">                .method(&quot;POST&quot;)</span>
<span class="fc" id="L3499">                .with(&quot;tag&quot;, tag)</span>
<span class="fc" id="L3500">                .with(&quot;message&quot;, message)</span>
<span class="fc" id="L3501">                .with(&quot;object&quot;, object)</span>
<span class="fc" id="L3502">                .with(&quot;type&quot;, type)</span>
<span class="fc" id="L3503">                .withUrlPath(getApiTailUrl(&quot;git/tags&quot;))</span>
<span class="fc" id="L3504">                .fetch(GHTagObject.class)</span>
<span class="fc" id="L3505">                .wrap(this);</span>
    }

    /**
     * Streams a zip archive of the repository, optionally at a given &lt;code&gt;ref&lt;/code&gt;.
     *
     * @param &lt;T&gt;
     *            the type of result
     * @param streamFunction
     *            The {@link InputStreamFunction} that will process the stream
     * @param ref
     *            if &lt;code&gt;null&lt;/code&gt; the repository's default branch, usually &lt;code&gt;main&lt;/code&gt;,
     * @return the result of reading the stream.
     * @throws IOException
     *             The IO exception.
     */
    public &lt;T&gt; T readZip(InputStreamFunction&lt;T&gt; streamFunction, String ref) throws IOException {
<span class="fc" id="L3522">        return downloadArchive(&quot;zip&quot;, ref, streamFunction);</span>
    }

    /**
     * Streams a tar archive of the repository, optionally at a given &lt;code&gt;ref&lt;/code&gt;.
     *
     * @param &lt;T&gt;
     *            the type of result
     * @param streamFunction
     *            The {@link InputStreamFunction} that will process the stream
     * @param ref
     *            if &lt;code&gt;null&lt;/code&gt; the repository's default branch, usually &lt;code&gt;main&lt;/code&gt;,
     * @return the result of reading the stream.
     * @throws IOException
     *             The IO exception.
     */
    public &lt;T&gt; T readTar(InputStreamFunction&lt;T&gt; streamFunction, String ref) throws IOException {
<span class="fc" id="L3539">        return downloadArchive(&quot;tar&quot;, ref, streamFunction);</span>
    }

    /**
     * Create a repository dispatch event, which can be used to start a workflow/action from outside github, as
     * described on https://docs.github.com/en/rest/reference/repos#create-a-repository-dispatch-event
     *
     * @param &lt;T&gt;
     *            type of client payload
     * @param eventType
     *            the eventType
     * @param clientPayload
     *            a custom payload , can be nullable
     * @throws IOException
     *             the io exception
     */
    public &lt;T&gt; void dispatch(String eventType, @Nullable T clientPayload) throws IOException {
<span class="fc" id="L3556">        root().createRequest()</span>
<span class="fc" id="L3557">                .method(&quot;POST&quot;)</span>
<span class="fc" id="L3558">                .withUrlPath(getApiTailUrl(&quot;dispatches&quot;))</span>
<span class="fc" id="L3559">                .with(&quot;event_type&quot;, eventType)</span>
<span class="fc" id="L3560">                .with(&quot;client_payload&quot;, clientPayload)</span>
<span class="fc" id="L3561">                .send();</span>
<span class="fc" id="L3562">    }</span>

    private &lt;T&gt; T downloadArchive(@Nonnull String type,
            @CheckForNull String ref,
            @Nonnull InputStreamFunction&lt;T&gt; streamFunction) throws IOException {
<span class="fc" id="L3567">        requireNonNull(streamFunction, &quot;Sink must not be null&quot;);</span>
<span class="fc" id="L3568">        String tailUrl = getApiTailUrl(type + &quot;ball&quot;);</span>
<span class="pc bpc" id="L3569" title="1 of 2 branches missed.">        if (ref != null) {</span>
<span class="nc" id="L3570">            tailUrl += &quot;/&quot; + ref;</span>
        }
<span class="fc" id="L3572">        final Requester builder = root().createRequest().method(&quot;GET&quot;).withUrlPath(tailUrl);</span>
<span class="fc" id="L3573">        return builder.fetchStream(streamFunction);</span>
    }

    /**
     * Populate this object.
     *
     * @throws IOException
     *             Signals that an I/O exception has occurred.
     */
    void populate() throws IOException {
<span class="fc bfc" id="L3583" title="All 2 branches covered.">        if (isOffline()) {</span>
<span class="fc" id="L3584">            return; // can't populate if the root is offline</span>
        }

        // We don't use the URL provided in the JSON because it is not reliable:
        // 1. There is bug in Push event payloads that returns the wrong url.
        // For Push event repository records, they take the form
        // &quot;https://github.com/{fullName}&quot;.
        // All other occurrences of &quot;url&quot; take the form &quot;https://api.github.com/...&quot;.
        // 2. For Installation event payloads, the URL is not provided at all.

<span class="fc" id="L3594">        root().createRequest().withUrlPath(getApiTailUrl(&quot;&quot;)).fetchInto(this);</span>
<span class="fc" id="L3595">    }</span>

    /**
     * A {@link GHRepositoryBuilder} that allows multiple properties to be updated per request.
     *
     * Consumer must call {@link #done()} to commit changes.
     */
    @BetaApi
    public static class Updater extends GHRepositoryBuilder&lt;Updater&gt; {

        /**
         * Instantiates a new updater.
         *
         * @param repository
         *            the repository
         */
        protected Updater(@Nonnull GHRepository repository) {
<span class="fc" id="L3612">            super(Updater.class, repository.root(), null);</span>
            // even when we don't change the name, we need to send it in
            // this requirement may be out-of-date, but we do not want to break it
<span class="fc" id="L3615">            requester.with(&quot;name&quot;, repository.name);</span>

<span class="fc" id="L3617">            requester.method(&quot;PATCH&quot;).withUrlPath(repository.getApiTailUrl(&quot;&quot;));</span>
<span class="fc" id="L3618">        }</span>
    }

    /**
     * Star a repository.
     *
     * @throws IOException
     *             the io exception
     */
    public void star() throws IOException {
<span class="fc" id="L3628">        root().createRequest().method(&quot;PUT&quot;).withUrlPath(String.format(&quot;/user/starred/%s&quot;, full_name)).send();</span>
<span class="fc" id="L3629">    }</span>

    /**
     * Unstar a repository.
     *
     * @throws IOException
     *             the io exception
     */
    public void unstar() throws IOException {
<span class="fc" id="L3638">        root().createRequest().method(&quot;DELETE&quot;).withUrlPath(String.format(&quot;/user/starred/%s&quot;, full_name)).send();</span>
<span class="fc" id="L3639">    }</span>

    /**
     * Get the top 10 popular contents over the last 14 days as described on
     * https://docs.github.com/en/rest/metrics/traffic?apiVersion=2022-11-28#get-top-referral-paths
     *
     * @return list of top referral paths
     * @throws IOException
     *             the io exception
     */
    public List&lt;GHRepositoryTrafficTopReferralPath&gt; getTopReferralPaths() throws IOException {
<span class="fc" id="L3650">        return Arrays.asList(root().createRequest()</span>
<span class="fc" id="L3651">                .method(&quot;GET&quot;)</span>
<span class="fc" id="L3652">                .withUrlPath(getApiTailUrl(&quot;/traffic/popular/paths&quot;))</span>
<span class="fc" id="L3653">                .fetch(GHRepositoryTrafficTopReferralPath[].class));</span>
    }

    /**
     * Get the top 10 referrers over the last 14 days as described on
     * https://docs.github.com/en/rest/metrics/traffic?apiVersion=2022-11-28#get-top-referral-sources
     *
     * @return list of top referrers
     * @throws IOException
     *             the io exception
     */
    public List&lt;GHRepositoryTrafficTopReferralSources&gt; getTopReferralSources() throws IOException {
<span class="fc" id="L3665">        return Arrays.asList(root().createRequest()</span>
<span class="fc" id="L3666">                .method(&quot;GET&quot;)</span>
<span class="fc" id="L3667">                .withUrlPath(getApiTailUrl(&quot;/traffic/popular/referrers&quot;))</span>
<span class="fc" id="L3668">                .fetch(GHRepositoryTrafficTopReferralSources[].class));</span>
    }

    /**
     * Get all active rules that apply to the specified branch
     * (https://docs.github.com/en/rest/repos/rules?apiVersion=2022-11-28#get-rules-for-a-branch).
     *
     * @param branch
     *            the branch
     * @return the rules for branch
     * @throws IOException
     *             the io exception
     */
    public PagedIterable&lt;GHRepositoryRule&gt; listRulesForBranch(String branch) throws IOException {
<span class="fc" id="L3682">        return root().createRequest()</span>
<span class="fc" id="L3683">                .method(&quot;GET&quot;)</span>
<span class="fc" id="L3684">                .withUrlPath(getApiTailUrl(&quot;/rules/branches/&quot; + branch))</span>
<span class="fc" id="L3685">                .toIterable(GHRepositoryRule[].class, null);</span>
    }

    /**
     * Check, if vulnerability alerts are enabled for this repository
     * (https://docs.github.com/en/rest/repos/repos?apiVersion=2022-11-28#check-if-vulnerability-alerts-are-enabled-for-a-repository).
     *
     * @return true, if vulnerability alerts are enabled
     * @throws IOException
     *             the io exception
     */
    public boolean isVulnerabilityAlertsEnabled() throws IOException {
<span class="fc" id="L3697">        return root().createRequest()</span>
<span class="fc" id="L3698">                .method(&quot;GET&quot;)</span>
<span class="fc" id="L3699">                .withUrlPath(getApiTailUrl(&quot;/vulnerability-alerts&quot;))</span>
<span class="pc bpc" id="L3700" title="1 of 2 branches missed.">                .fetchHttpStatusCode() == 204;</span>
    }

    /**
     * A {@link GHRepositoryBuilder} that allows multiple properties to be updated per request.
     *
     * Consumer must call {@link #done()} to commit changes.
     */
    @BetaApi
    public static class Setter extends GHRepositoryBuilder&lt;GHRepository&gt; {

        /**
         * Instantiates a new setter.
         *
         * @param repository
         *            the repository
         */
        protected Setter(@Nonnull GHRepository repository) {
<span class="fc" id="L3718">            super(GHRepository.class, repository.root(), null);</span>
            // even when we don't change the name, we need to send it in
            // this requirement may be out-of-date, but we do not want to break it
<span class="fc" id="L3721">            requester.with(&quot;name&quot;, repository.name);</span>

<span class="fc" id="L3723">            requester.method(&quot;PATCH&quot;).withUrlPath(repository.getApiTailUrl(&quot;&quot;));</span>
<span class="fc" id="L3724">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>